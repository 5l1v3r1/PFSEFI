Only in /Users/QGuan/Downloads/temu-1.0: INSTALL
diff --exclude=tracecap -ur PFSEFI_for_patch/Makefile.target /Users/QGuan/Downloads/temu-1.0/Makefile.target
--- PFSEFI_for_patch/Makefile.target	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/Makefile.target	2009-11-23 12:38:07.000000000 -0700
@@ -39,7 +39,7 @@
 BASE_CFLAGS=
 BASE_LDFLAGS= 
 #CFLAGS+=-Werror
-LIBS=-ldl
+LIBS=
 HELPER_CFLAGS=$(CFLAGS)
 DYNGEN=../dyngen$(EXESUF)
 # user emulator name
@@ -82,10 +82,6 @@
 else
 QEMU_SYSTEM=qemu-fast
 endif
-ifeq ($(TARGET_ARCH), x86_64)
-# XXX globally save %ebx, %esi, %edi on entry to generated function
-OP_CFLAGS+= -fcall-used-ebx -fcall-used-esi -fcall-used-edi
-endif
 
 ifdef CONFIG_USER_ONLY
 PROGS=$(QEMU_USER)
@@ -121,7 +117,7 @@
 
 ifeq ($(ARCH),i386)
 HELPER_CFLAGS+=-fomit-frame-pointer
-OP_CFLAGS+=-fomit-frame-pointer
+OP_CFLAGS+=-mpreferred-stack-boundary=2 -fomit-frame-pointer
 ifdef TARGET_GPROF
 USE_I386_LD=y
 endif
@@ -576,7 +572,7 @@
 LDFLAGS+= -export-dynamic
 $(QEMU_SYSTEM): $(VL_OBJS) ../libqemu_common.a libqemu.a
 	$(CC) $(VL_LDFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS) $(SDL_LIBS) $(COCOA_LIBS) $(VL_LIBS)
-	cp $(QEMU_SYSTEM) $(SRC_PATH)/$(PROJECT_NAME)/fsefi
+	cp $(QEMU_SYSTEM) $(SRC_PATH)/$(PROJECT_NAME)/temu
 
 depend: $(SRCS)
 	$(CC) -MM $(CFLAGS) $(CPPFLAGS) $(BASE_CFLAGS) $^ 1>.depend
Only in PFSEFI_for_patch: Makefile.target.orig
Only in PFSEFI_for_patch: Makefile.target.rej
Only in PFSEFI_for_patch: PFSEFI
Only in PFSEFI_for_patch: SEFI.log.ppopp
Only in PFSEFI_for_patch: SEFI_CG.log
Only in PFSEFI_for_patch: SEFI_FT.log
Only in PFSEFI_for_patch: SEFI_README
Only in PFSEFI_for_patch: SEFI_conf.ini
diff --exclude=tracecap -ur PFSEFI_for_patch/TEMU_lib.h /Users/QGuan/Downloads/temu-1.0/TEMU_lib.h
--- PFSEFI_for_patch/TEMU_lib.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/TEMU_lib.h	2009-11-23 12:38:10.000000000 -0700
@@ -95,8 +95,6 @@
 
 /// Send a keystroke
 void do_send_key(const char *string);
-void do_send_string(const char *str);
-
 /*! @} */ //end of group
 
 
diff --exclude=tracecap -ur PFSEFI_for_patch/TEMU_main.c /Users/QGuan/Downloads/temu-1.0/TEMU_main.c
--- PFSEFI_for_patch/TEMU_main.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/TEMU_main.c	2009-11-23 12:38:07.000000000 -0700
@@ -23,7 +23,6 @@
 #include "../shared/hookapi.h"
 
 
-
 int TEMU_emulation_started = 0;
 plugin_interface_t *temu_plugin = NULL;
 int should_monitor = 1;
@@ -47,12 +46,6 @@
 unsigned int * TEMU_cpu_fpuc = NULL;
 uint8_t * TEMU_cpu_fptags = NULL;
 
-// Added by Guan
-inject_info_t *temu_inject= NULL;
-#define LOGEFILE "SEFI.log"
-FILE *SEFI_log = NULL;
-//
-
 #if TAINT_FLAGS
 uint32_t TEMU_eflags = 0;
 #endif
@@ -64,9 +57,6 @@
 static void *plugin_handle = NULL;
 static char temu_plugin_path[PATH_MAX]="";
 
-void clean_probability();
-
-
 void do_enable_emulation()
 {
   if(!TEMU_emulation_started) {
@@ -75,7 +65,7 @@
 	}
 	else {
 	  TEMU_emulation_started = 1;
-	  term_printf("Emulation is now enabled !\n");
+	  term_printf("Emulation is now enabled\n");
 	}
   }
   else 
@@ -90,267 +80,6 @@
   }
 }
 
-/************************************************************************************/
-// by Guan 
-// Init the inject information 
-static inject_info_t my_temu_inject;
-inject_info_t *init_inject(){
-  my_temu_inject.start_addr = 0;
-  my_temu_inject.end_addr = 0;
-  my_temu_inject.is_inject_allowed = 0;
-  my_temu_inject.is_inject_triggered = 0;
-  my_temu_inject.counter = 0;
-  my_temu_inject.inject_type = SEFI_NONE;
-  strcpy(my_temu_inject.func_name, "");
-  strcpy(my_temu_inject.target_name, "");
-  strcpy(my_temu_inject.guest_output_name, "");
-  // Init the Profile mode
-  // my_temu_inject.profile_type = SEFI_PROFILE_NONE;
-  //my_temu_inject.prof_proc_state = SEFI_PROC_STATE_INIT;
-  return &my_temu_inject;
-}
-// added by -- Guan
-// Functions used for configuring and controlling the injection
-// These Funcs are called by cpu-exe.c (control) or target-i388/op.c (configuration)
-void SEFI_inject_mem_region(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->inject_start_addr = temu_inject->start_addr;
-  cur_env->inject_end_addr = temu_inject->end_addr;
-
-}
-void SEFI_inject_allow(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->is_inject_allowed = temu_inject->is_inject_allowed;
-}
- 
-void SEFI_inject_trigger(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->is_inject_triggered= temu_inject->is_inject_triggered;
-}
-
-void SEFI_inject_counter(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->counter= temu_inject->counter;
-}
-
-// added for multiple injection  -- guanxyz
-void SEFI_inject_dic(uint64_t *arr, uint64_t sz){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  int i;
-  for(i=0; i<sz; i++){
-    cur_env->p_chosen_dic[i] = *(arr+i);
-  }
-  term_printf("\nShowing all candidates: ");
-  for(i=0; i<sz; i++)
-    	term_printf(" %d ", (uint64_t)*(arr+i));
-  term_printf("\n");
- // memcpy(cur_env->p_chosen_dic, temu_inject->chosen_candidates, temu_inject->counter*sizeof(uint64_t));
-}
-
-void SEFI_inject_type(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->inject_type= temu_inject->inject_type;
-}
-
-void SEFI_inject_funcname(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  strcpy(cur_env->func_name, temu_inject->func_name);
-}
-
-void SEFI_inject_conf(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->start_bit = temu_inject->bitflip_conf.start_bit;
-  cur_env->end_bit = temu_inject->bitflip_conf.end_bit;
-  cur_env->num_bit = temu_inject->bitflip_conf.num_bit;
-  cur_env->fault_probability = temu_inject->bitflip_conf.fault_probability;
-  cur_env->start_of_fadd = temu_inject->bitflip_conf.start_of_fadd;
-  cur_env->start_of_fmul = temu_inject->bitflip_conf.start_of_fmul;
-  cur_env->start_of_cmp = temu_inject->bitflip_conf.start_of_cmp;
-  cur_env->start_of_xor = temu_inject->bitflip_conf.start_of_xor;
-  // may need to add others 
-  cur_env->start_of_idivl = temu_inject->bitflip_conf.start_of_idivl;
-  cur_env->start_of_imul = temu_inject->bitflip_conf.start_of_imul;
-  cur_env->start_of_iaddl = temu_inject->bitflip_conf.start_of_iaddl;
-  cur_env->start_of_isubl = temu_inject->bitflip_conf.start_of_isubl;
-  // Other  ALU
-  cur_env->start_of_shrl = temu_inject->bitflip_conf.start_of_shrl;
-  cur_env->start_of_orl = temu_inject->bitflip_conf.start_of_orl;
-  cur_env->start_of_xorl = temu_inject->bitflip_conf.start_of_xorl;
-  cur_env->start_of_movl = temu_inject->bitflip_conf.start_of_movl;
-  cur_env->start_of_testl = temu_inject->bitflip_conf.start_of_testl;
-  cur_env->start_of_notl = temu_inject->bitflip_conf.start_of_notl;
-  // Load
-  cur_env->start_of_ld = temu_inject->bitflip_conf.start_of_ld;
-  //
-  cur_env->chosen_dic = temu_inject->bitflip_conf.chosen_dic;
-}
-
-void SEFI_clear_inject(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  temu_inject = init_inject();
-  // Clear all information about injection
-  cur_env->inject_start_addr = temu_inject->start_addr;
-  cur_env->inject_end_addr = temu_inject->end_addr;
-
-  cur_env->is_inject_allowed = temu_inject->is_inject_allowed;
-  cur_env->is_inject_triggered= temu_inject->is_inject_triggered;
-  cur_env->counter= temu_inject->counter;
-  cur_env->inject_type = temu_inject->inject_type;
-  strcpy(cur_env->func_name, temu_inject->func_name);
-  // profile only
-  //cur_env->profile_type = temu_inject->profile_type;
-  cur_env->fadd_count = 0;   // To make sure that all counters have been clear up
-  cur_env->fmul_count = 0;
-  cur_env->cmp_count = 0;
-  cur_env->xor_count = 0;
-  cur_env->sarl_count = 0;
-  cur_env->idivl_count = 0;
-  cur_env->imul_count = 0;
-  cur_env->iaddl_count=0;
-  cur_env->isubl_count=0;
-  cur_env->shrl_count=0;
-  cur_env->andl_count=0;
-  cur_env->orl_count=0;
-  cur_env->xorl_count=0;
-  cur_env->movl_count=0;
-  cur_env->testl_count=0;
-  cur_env->ld_count=0;
-  cur_env->num_corruptions=0;
-  //cur_env->prof_proc_state = temu_inject->prof_proc_state;
- // clean_probability();
-  //proba_clean();
-}
-
-void SEFI_conf_profile(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  //cur_env->profile_type = temu_inject->profile_type;
-  cur_env->fadd_count = 0;   // To make sure that all counters have been clear up
-  cur_env->fmul_count = 0;
-  cur_env->cmp_count = 0;
-  cur_env->xor_count = 0;
-  cur_env->sarl_count = 0;
-  cur_env->idivl_count= 0;
-  cur_env->imul_count= 0;
-  cur_env->iaddl_count=0;
-  cur_env->isubl_count=0;
-  cur_env->shrl_count=0;
-  cur_env->andl_count=0;
-  cur_env->orl_count=0;
-  cur_env->xorl_count=0;
-  cur_env->movl_count=0;
-  cur_env->testl_count=0;
-  cur_env->notl_count=0;
-  cur_env->ld_count=0;
-  cur_env->num_corruptions=0;
-  
-}
-
-// Read the counters 
-void SEFI_get_profile(uint64_t *fadd_n, uint64_t *fmul_n, uint64_t *cmp_n, 
-    uint64_t *sarl_n, uint64_t *idivl_n, uint64_t *imul_n, uint64_t *iaddl_n, uint64_t *isubl_n, 
-    uint64_t *shrl_n, uint64_t *andl_n, uint64_t *orl_n, uint64_t *xorl_n, uint64_t *movl_n, uint64_t *testl_n, uint64_t *notl_n, uint64_t *ld_n){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  *fadd_n = cur_env->fadd_count;
-  *fmul_n = cur_env->fmul_count;
-  //*xor_n = cur_env->xor_count;
-  *cmp_n = cur_env->cmp_count;
-  *sarl_n = cur_env->sarl_count;
-  *idivl_n = cur_env->idivl_count;
-  *imul_n = cur_env->imul_count;
-  *iaddl_n = cur_env->iaddl_count;
-  *isubl_n = cur_env->isubl_count;
-  *shrl_n = cur_env->shrl_count;
-  *andl_n = cur_env->andl_count;
-  *orl_n = cur_env->orl_count;
-  *xorl_n = cur_env->xorl_count;
-  *movl_n = cur_env->movl_count;
-  *testl_n = cur_env->testl_count;
-  *notl_n = cur_env->notl_count;
-  *ld_n = cur_env->ld_count;
-}
-
-void SEFI_clear_counters(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->fadd_count = 0;
-  cur_env->fmul_count = 0;
-  cur_env->xor_count = 0;
-  cur_env->cmp_count = 0;
-  cur_env->sarl_count = 0;
-  cur_env->idivl_count = 0;
-  cur_env->imul_count = 0;
-  cur_env->iaddl_count=0;
-  cur_env->isubl_count=0;
-  cur_env->shrl_count=0;
-  cur_env->andl_count=0;
-  cur_env->orl_count=0;
-  cur_env->xorl_count=0;
-  cur_env->movl_count=0;
-  cur_env->testl_count=0;
-  cur_env->notl_count=0;
-  cur_env->ld_count=0;
-}
-
-// To update the monitored process info
-/*
-void SEFI_update_process_state(){
-  CPUState *cur_env = cpu_single_env?cpu_single_env:first_cpu;
-  cur_env->prof_proc_state = temu_inject->prof_proc_state;
-}
-*/
-int SEFI_initlog(){
-  SEFI_log = fopen(LOGEFILE, "a+");
-  if(!SEFI_log){
-    fprintf(stderr, "cannot create log\n");
-    return 0;
-  }
-  return 1;
-}
-
-void SEFI_writelog(const char *appname, const char *fmt, ...){
-  if(!SEFI_log){
-    fprintf(stderr, "cannot find log\n");
-    return;
-  }
-  va_list listpointer;
-
-  va_start(listpointer, fmt);  // fmt is the first va pointer for localization
-  char buf[64];
-  time_t now;
-  
-  // Get Time Stamp
-  now = time(NULL);
-  struct tm *timeinfo;
-  timeinfo = localtime(&now);
-
-  strftime(buf, 64, "[%d,%b,%H:%M:%S]", timeinfo);
-  
-  fprintf(SEFI_log, "%s [%s] ", buf, appname);        //print the time stamp
-  vfprintf(SEFI_log, fmt, listpointer); //print the data into stream FILE
-  //fprintf(SEFI_log, "\n");
-
-  fflush(SEFI_log); // flush the buffer and write the buffer into file
-  va_end(listpointer);
-  
-}
-
-void SEFI_closelog(){
-  fclose(SEFI_log);
-  SEFI_log=NULL;
-}
-
-void SEFI_init_rand(){
-  srand((unsigned int)time(NULL));
-}
-
-void SEFI_log_profile(){
-  CPUState *cur_env = cpu_single_env? cpu_single_env: first_cpu;
-  if(cur_env->profile_type != SEFI_PROFILE_NONE)
-    SEFI_writelog(cur_env->func_name, "FaddCount:%d, FmulCouont:%d \n", 
-                                     cur_env->fadd_count, 
-				     cur_env->fmul_count);
-  
-}
-/************************************************************************************/
 
 void do_load_plugin(const char *plugin_path)
 {
@@ -385,21 +114,6 @@
     plugin_handle = NULL;
     return;
   }
-  
- 	#ifdef USE_X86LDOUBLE
-	term_printf("------ THE EXTENDED PRECISION is ENABLED.\n");  
-	#endif
-
-  // Init for injection -- Guan
-  temu_inject = init_inject();
-  if(NULL == temu_inject){
-    term_printf("fail to initialize the plugin!\n");
-    return;
-  }
-  // To init the SEFI log -- Guan
-  SEFI_initlog(); 
-  SEFI_init_rand();
-  //
 
   temulog = fopen("temu.log", "w");
   assert(temulog != NULL);
@@ -434,38 +148,11 @@
 #if TAINT_ENABLED
     taintcheck_cleanup();
 #endif
-    // Clear all injection information
-    // SEFI_log_profile(); -- Need to modify
-    SEFI_clear_inject();
-    SEFI_closelog(); // Close the log -- Guan
     term_printf("%s is unloaded!\n", temu_plugin_path);
     temu_plugin_path[0] = 0;
   }
 }
 
-/* Function */
-/*
- * Reboot SEFI probe
- */ 
-
-void do_reboot_SEFI(){
-  
-  if (!temu_plugin_path[0]) {
-    term_printf("%s does not exist! \n", temu_plugin_path);
-    return;
-  }
-  // copy path
-  char path_copy[PATH_MAX];
-  strncpy(path_copy, temu_plugin_path, PATH_MAX);
-
-  do_unload_plugin();
-
-  do_load_plugin(path_copy);
-
-  do_enable_emulation();
-  
-  SEFI_clear_counters(); 
-}
 
 /*
  * Update CPU States 
@@ -501,6 +188,7 @@
   }
 }
 
+
 /*
  * NIC related functions
  */
@@ -1081,3 +769,4 @@
 #endif
 }
 
+
diff --exclude=tracecap -ur PFSEFI_for_patch/TEMU_main.h /Users/QGuan/Downloads/temu-1.0/TEMU_main.h
--- PFSEFI_for_patch/TEMU_main.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/TEMU_main.h	2009-11-23 12:38:06.000000000 -0700
@@ -236,9 +236,6 @@
 ///send a keystroke into the guest system
 void do_send_key(const char *string);
 
-// Send a string(space is accepted) into guest system --by guanxyz
-void do_send_string(const char *str);
-
 /// \brief read or write a physical memory region
 ///
 /// @param addr physical address
@@ -424,148 +421,6 @@
 
 } plugin_interface_t;
 
-// added by Guan
-#define SEFI_TYPE_FADD		1
-#define SEFI_TYPE_FMUL		2
-#define SEFI_TYPE_CMP	 	3	// For Graph 500
-#define SEFI_TYPE_XOR	 	4	// For cpu_suite/bmm -- Retired and replaced by SEFI_TYPE_XORL - guanxyz
-#define SEFI_TYPE_SARL	 	5	// Shift for binary gcd
-#define SEFI_TYPE_IDIVL	 	6	// Reminder for eculid gcd
-#define SEFI_TYPE_IMULL		7	// integer multiply
-#define SEFI_TYPE_IADDL		8	// integer addition
-#define SEFI_TYPE_ISUBL		9
-#define SEFI_TYPE_SHRL		10
-#define SEFI_TYPE_ANDL		11
-#define SEFI_TYPE_ORL		12
-#define SEFI_TYPE_XORL		13
-#define SEFI_TYPE_MOVL		14
-#define SEFI_TYPE_TESTL		15
-#define SEFI_TYPE_NOTL		16
-#define SEFI_TYPE_LD		17
-#define SEFI_TYPE_ST		18
-//#define SEFI_TYPE_HYBRID	3
-#define SEFI_NONE		(uint32_t)0
-#define SEFI_FADD_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_FADD)	
-#define SEFI_FMUL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_FMUL)
-#define SEFI_CMP_BIT_FLIP   	(uint32_t)(1<<SEFI_TYPE_CMP)
-#define SEFI_XOR_BIT_FLIP   	(uint32_t)(1<<SEFI_TYPE_XOR)
-#define SEFI_SARL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_SARL)
-#define SEFI_IDIVL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_IDIVL)
-#define SEFI_IMULL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_IMULL)	// For MM
-#define SEFI_IADDL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_IADDL)	// For MM
-#define SEFI_ISUBL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_ISUBL)	
-#define SEFI_SHRL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_SHRL)	
-#define SEFI_ANDL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_ANDL)	
-#define SEFI_ORL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_ORL)	
-#define SEFI_XORL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_XORL)	
-#define SEFI_MOVL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_MOVL)	
-#define SEFI_TESTL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_TESTL)	
-#define SEFI_NOTL_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_NOTL)	
-#define SEFI_LD_BIT_FLIP	(uint32_t)(1<<SEFI_TYPE_LD)	
-#define SEFI_HYBRID_BIT_FLIP    (uint32_t)(SEFI_FADD_BIT_FLIP|SEFI_FMUL_BIT_FLIP)
-// define profile interest
-#define SEFI_PROFILE_NONE 	(uint32_t)0
-#define SEFI_PROFILE_FADD	(uint32_t)(1<<SEFI_TYPE_FADD)
-#define SEFI_PROFILE_FMUL	(uint32_t)(1<<SEFI_TYPE_FMUL)
-#define SEFI_PROFILE_CMP	(uint32_t)(1<<SEFI_TYPE_CMP)
-#define SEFI_PROFILE_XOR	(uint32_t)(1<<SEFI_TYPE_XOR)
-#define SEFI_PROFILE_SARL	(uint32_t)(1<<SEFI_TYPE_SARL)
-#define SEFI_PROFILE_IDIVL	(uint32_t)(1<<SEFI_TYPE_IDIVL)
-#define SEFI_PROFILE_IMULL	(uint32_t)(1<<SEFI_TYPE_IMULL)	// For MM
-#define SEFI_PROFILE_IADDL	(uint32_t)(1<<SEFI_TYPE_IADDL)	// For MM
-#define SEFI_PROFILE_ISUBL	(uint32_t)(1<<SEFI_TYPE_ISUBL)
-#define SEFI_PROFILE_SHRL	(uint32_t)(1<<SEFI_TYPE_SHRL)
-#define SEFI_PROFILE_ANDL	(uint32_t)(1<<SEFI_TYPE_ANDL)
-#define SEFI_PROFILE_ORL	(uint32_t)(1<<SEFI_TYPE_ORLL)
-#define SEFI_PROFILE_XORL	(uint32_t)(1<<SEFI_TYPE_XORL)
-#define SEFI_PROFILE_MOVL	(uint32_t)(1<<SEFI_TYPE_MOVL)
-#define SEFI_PROFILE_TESTL	(uint32_t)(1<<SEFI_TYPE_TESTL)
-#define SEFI_PROFILE_NOTL	(uint32_t)(1<<SEFI_TYPE_NOTL)
-#define SEFI_PROFILE_LD		(uint32_t)(1<<SEFI_TYPE_LD)
-#define SEFI_PROFILE_HYBRID	(uint32_t)(SEFI_PROFILE_FADD)|SEFI_PROFILE_FMUL
-
-// Fault injection
-//  --by Guan
-typedef struct bitflip_conf_t{
-  uint8_t fadd_allowed;
-  uint8_t fmul_allowed;
-  uint8_t cmp_allowed;			// for graph 500 benchmark
-  uint8_t xor_allowed;			// for cpu_suite/bmm
-  uint8_t sarl_allowed;			// for binary gcd
-  uint8_t idivl_allowed;		// for euclid gcd
-  uint8_t imul_allowed;		// for MM 
-  uint8_t iaddl_allowed;		// for MM 
-  uint8_t isubl_allowed;
-  uint8_t shrl_allowed;
-  uint8_t andl_allowed;
-  uint8_t orl_allowed;
-  uint8_t xorl_allowed;
-  uint8_t movl_allowed;
-  uint8_t testl_allowed;
-  uint8_t notl_allowed;
-  uint8_t ld_allowed;
-  uint16_t start_bit;
-  uint16_t end_bit;
-  uint16_t num_bit;
-  double fault_probability;
-  uint64_t start_of_fadd;
-  uint64_t start_of_fmul;
-  uint64_t start_of_cmp;		// for graph 500 benchmark
-  uint64_t start_of_xor;		// for cpu_suite/bmm
-  uint64_t start_of_sarl;
-  uint64_t start_of_idivl;
-  uint64_t start_of_imul;		// for MM - Will and Rusty
-  uint64_t start_of_iaddl;		// for Maryland
-  uint64_t start_of_isubl;		// for Maryland
-  uint64_t start_of_shrl;		// for Maryland
-  uint64_t start_of_andl;		// for Maryland
-  uint64_t start_of_orl;		// for Maryland
-  uint64_t start_of_xorl;		// for Maryland
-  uint64_t start_of_movl;		// for Maryland
-  uint64_t start_of_testl;
-  uint64_t start_of_notl;
-  uint64_t start_of_ld;			// For Panruo
-  uint64_t chosen_dic;
-}bitflip_conf_t;
-
-typedef struct profile_op_t{
-  uint64_t fadd_count;
-  uint64_t fmul_count;
-  uint64_t cmp_count;
-  uint64_t xor_count;
-  uint64_t sarl_count;
-  uint64_t idivl_count;
-  uint64_t imul_count;
-  uint64_t iaddl_count;
-  uint64_t isubl_count;
-  uint64_t shrl_count;
-  uint64_t andl_count;
-  uint64_t orl_count;
-  uint64_t xorl_count;
-  uint64_t movl_count;
-  uint64_t testl_count;
-  uint64_t notl_count;
-  uint64_t ld_count;
-}profile_op_t;
-
-typedef struct{
-  uint32_t start_addr;            // Interested memory region boundary
-  uint32_t end_addr;              // Interested memory region boundary
-  uint8_t is_inject_allowed;      // Controllor
-  uint8_t is_inject_triggered;    // Controllor
-  uint64_t counter;        	  // Number of inject faults
-  uint16_t inject_type;     	  // SEFI_FADD_BIT_FLIP, SEFI_FMUL_BIT_FLIP, SEFI_HYBRID_BIT_FLIP
-  char func_name[128];  	  // Name of function specified
-  struct bitflip_conf_t bitflip_conf;   // configuration of bitflip faults injector
-  char  output_conf[512];	// configuration of output Guest App
-  uint16_t profile_type;		  // if profile_type = 0 means profile isnot set	
-  uint16_t prof_proc_state;	  // process states under profile
-  char target_name[64];		  // Asyn cmd execution
-  char guest_output_name[64];	  // output file name in guest( it will be sent back to host)
-  uint64_t *chosen_candidates; // chosen candidates to inject faults
-}inject_info_t;
-
-
 /// This flag tells if emulation mode is enabled
 extern int TEMU_emulation_started;
 
@@ -641,7 +496,6 @@
 
 
 extern plugin_interface_t *temu_plugin;
-extern  inject_info_t *temu_inject;
 extern void * TEMU_KbdState;
 extern int should_monitor; //!<this flag indicates whether the plugin should receive callback
 
@@ -652,7 +506,6 @@
 void do_disable_emulation(void);
 void do_load_plugin(const char *plugin_path);
 void do_unload_plugin(void);
-void do_reboot_SEFI(); // function to reboot the SEFI environment
 void TEMU_nic_receive(const uint8_t * buf, int size, int cur_pos, int start, int stop);
 void TEMU_nic_send(uint32_t addr, int size, uint8_t * buf);
 void TEMU_nic_in(uint32_t addr, int size);
@@ -676,23 +529,6 @@
 void TEMU_update_cpustate();
 void TEMU_loadvm(void *opaque);
 
-void SEFI_inject_mem_region();
-void SEFI_inject_allow();
-void SEFI_inject_trigger();
-void SEFI_inject_counter();
-void SEFI_inject_funcname();
-void SEFI_inject_type();
-void SEFI_writelog(const char *appname, const char *fmt, ...); //Write SEFI ralated logs
-void SEFI_init_rand();
-void SEFI_inject_conf(); //load the bitflip configuration
-void SEFI_conf_profile(); // configure the profiler
-void SEFI_get_profile(uint64_t *fadd_n, uint64_t *fmul_n, uint64_t *cmp_n,  
-    uint64_t *sarl_n, uint64_t *idivl_n, uint64_t *imul_n, uint64_t *iaddl_n, uint64_t *isubl_n, 
-    uint64_t *shrl_n, uint64_t *andl_n, uint64_t *orl_n, uint64_t *xorl_n, uint64_t *movl_n, uint64_t *testl_n, uint64_t *notl_n, uint64_t *ld_n);
- 
-void SEFI_clear_counters();	// for chosen sites
-void SEFI_inject_dic(uint64_t *arr, uint64_t sz);
-//void SEFI_update_process_state(); // update process(under profile) state
 
 #include "TEMU_vm_compress.h"
 
Only in PFSEFI_for_patch: a.out
diff --exclude=tracecap -ur PFSEFI_for_patch/block-raw-posix.c /Users/QGuan/Downloads/temu-1.0/block-raw-posix.c
--- PFSEFI_for_patch/block-raw-posix.c	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/block-raw-posix.c	2009-11-23 12:38:08.000000000 -0700
@@ -56,7 +56,6 @@
 #include <sys/disk.h>
 #endif
 
-#include <signal.h>
 //#define DEBUG_FLOPPY
 
 //#define DEBUG_BLOCK
Only in PFSEFI_for_patch: commands.c.backup
Only in PFSEFI_for_patch: config-host.h
Only in PFSEFI_for_patch: config-host.mak
Only in PFSEFI_for_patch: configme.sh
Only in PFSEFI_for_patch: configureme.sh
Only in PFSEFI_for_patch: cp_log.sh
diff --exclude=tracecap -ur PFSEFI_for_patch/cpu-all.h /Users/QGuan/Downloads/temu-1.0/cpu-all.h
--- PFSEFI_for_patch/cpu-all.h	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/cpu-all.h	2009-11-23 12:38:10.000000000 -0700
@@ -369,13 +369,7 @@
 
 static inline void stq_le_p(void *ptr, uint64_t v)
 {
-#if defined(__i386__) && __GNUC__ >= 4
-    const union { uint64_t v; uint32_t p[2]; } x = { .v = v };
-    ((uint32_t *)ptr)[0] = x.p[0];
-    ((uint32_t *)ptr)[1] = x.p[1];
-#else
     *(uint64_t *)ptr = v;
-#endif
 }
 
 /* float access */
Only in PFSEFI_for_patch: cpu-all.h.orig
Only in PFSEFI_for_patch: cpu-all.h.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/cpu-exec.c /Users/QGuan/Downloads/temu-1.0/cpu-exec.c
--- PFSEFI_for_patch/cpu-exec.c	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/cpu-exec.c	2009-11-23 12:38:06.000000000 -0700
@@ -646,37 +646,10 @@
                     spin_lock(&tb_lock);
                     tb_add_jump((TranslationBlock *)(long)(T0 & ~3), T0 & 3, tb);
                     spin_unlock(&tb_lock);
-                    }
+                }
                 }
                 tc_ptr = tb->tc_ptr;
                 env->current_tb = tb;
-		 
-		 // Added by Guan
-	         /* check the fault inject status */
-		if(env->is_inject_allowed){
-		  if(env->eip >= env->inject_start_addr && env->eip <= env->inject_end_addr){
-    		   // printf("Start: 0x%08X --  eip: 0x%08X --  end:0x%08X \n", 
-		   //                        env->inject_start_addr,
-		   // 			   env->eip, 
-		   // 			   env->inject_end_addr);
-		   
-    		  // printf("FADD Count: %d, FMUL Count:%d CMP Count:%d SARL Count:%d\n", env->fadd_count, env->fmul_count, env->cmp_count, env->sarl_count );
-		     // Call the function to triger faults 
-		   env->is_inject_triggered = 1;
-		  }
-		  /*
-		  else{ 
-		    if(env->prof_proc_state == 2){ // 2: start state
-    		    printf("Current Profile Process State:%d \n", env->prof_proc_state);
-    		    printf("FADD Count: %d, FMUL Count:%d \n", env->fadd_count, env->fmul_count );
-		   	 env->prof_proc_state = 0; // 3: end state
-		    } 
-		  }
-		  */
-		}
-		///////////////////////////////////////////
-		
-
                 /* execute the generated code */
                 gen_func = (void *)tc_ptr;
 #if defined(__sparc__)
@@ -695,15 +668,6 @@
                               : /* no outputs */
                               : "r" (gen_func)
                               : "r1", "r2", "r3", "r8", "r9", "r10", "r12", "r14");
-#elif defined(TARGET_X86_64) && defined(__i386__)
-                asm volatile ("push %%ebx\n"
-                              "push %%esi\n"
-                              "push %%edi\n"
-                              "call *%0\n"
-                              "pop %%edi\n"
-                              "pop %%esi\n"
-                              "pop %%ebx\n"
-                              : : "r" (gen_func) : "ebx", "esi", "edi");
 #elif defined(__ia64)
 		struct fptr {
 			void *ip;
Only in PFSEFI_for_patch: cpu-exec.c.orig
Only in PFSEFI_for_patch: cpu-exec.c.rej
Only in PFSEFI_for_patch: do_compile.sh
Only in PFSEFI_for_patch/docs: doxygen
Only in PFSEFI_for_patch/docs: doxygen.cfg
Only in PFSEFI_for_patch/docs: install-fsefi.sh
Binary files PFSEFI_for_patch/docs/temu-docs.tgz and /Users/QGuan/Downloads/temu-1.0/docs/temu-docs.tgz differ
diff --exclude=tracecap -ur PFSEFI_for_patch/dyngen-exec.h /Users/QGuan/Downloads/temu-1.0/dyngen-exec.h
--- PFSEFI_for_patch/dyngen-exec.h	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/dyngen-exec.h	2009-11-23 12:38:07.000000000 -0700
@@ -194,12 +194,7 @@
 #endif
 
 /* force GCC to generate only one epilog at the end of the function */
-#if defined(__i386__) || defined(__x86_64__)
-/* Also add 4 bytes of padding so that we can replace the ret with a jmp.  */
-#define FORCE_RET() asm volatile ("nop;nop;nop;nop");
-#else
 #define FORCE_RET() __asm__ __volatile__("" : : : "memory");
-#endif
 
 #ifndef OPPROTO
 #define OPPROTO
@@ -256,18 +251,11 @@
 #endif
 
 #if defined(__i386__)
-/* Dyngen will replace hlt instructions with a ret instruction.  Inserting a
-   ret directly would confuse dyngen.  */
-#define EXIT_TB() asm volatile ("hlt")
-/* Dyngen will replace cli with 0x9e (jmp). 
-   We generate the offset manually.  */
-#define GOTO_LABEL_PARAM(n) \
-  asm volatile ("cli;.long " ASM_NAME(__op_gen_label) #n " - 1f;1:")
+#define EXIT_TB() asm volatile ("ret")
+#define GOTO_LABEL_PARAM(n) asm volatile ("jmp " ASM_NAME(__op_gen_label) #n)
 #elif defined(__x86_64__)
-/* The same as i386.  */
-#define EXIT_TB() asm volatile ("hlt")
-#define GOTO_LABEL_PARAM(n) \
-  asm volatile ("cli;.long " ASM_NAME(__op_gen_label) #n " - 1f;1:")
+#define EXIT_TB() asm volatile ("ret")
+#define GOTO_LABEL_PARAM(n) asm volatile ("jmp " ASM_NAME(__op_gen_label) #n)
 #elif defined(__powerpc__)
 #define EXIT_TB() asm volatile ("blr")
 #define GOTO_LABEL_PARAM(n) asm volatile ("b " ASM_NAME(__op_gen_label) #n)
Only in PFSEFI_for_patch: dyngen-exec.h.orig
Only in PFSEFI_for_patch: dyngen-exec.h.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/dyngen.c /Users/QGuan/Downloads/temu-1.0/dyngen.c
--- PFSEFI_for_patch/dyngen.c	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/dyngen.c	2009-11-23 12:38:06.000000000 -0700
@@ -32,8 +32,6 @@
 
 #include "config-host.h"
 
-//#define DEBUG_OP
-
 /* NOTE: we test CONFIG_WIN32 instead of _WIN32 to enabled cross
    compilation */
 #if defined(CONFIG_WIN32)
@@ -1431,677 +1429,6 @@
 #endif
 
 
-#if defined(HOST_I386) || defined(HOST_X86_64)
-
-/* This byte is the first byte of an instruction.  */
-#define FLAG_INSN     (1 << 0)
-/* This byte has been processed as part of an instruction.  */
-#define FLAG_SCANNED  (1 << 1)
-/* This instruction is a return instruction.  Gcc cometimes generates prefix
-   bytes, so may be more than one byte long.  */
-#define FLAG_RET      (1 << 2)
-/* This is either the target of a jump, or the preceeding instruction uses
-   a pc-relative offset.  */
-#define FLAG_TARGET   (1 << 3)
-/* This is a magic instruction that needs fixing up.  */
-#define FLAG_EXIT     (1 << 4)
-/* This instruction clobbers the stack pointer.  */
-/* XXX only supports push, pop, add/sub $imm,%esp  */
-#define FLAG_STACK    (1 << 5)
-#define MAX_EXITS     5
-
-static void
-bad_opcode(const char *name, uint32_t op)
-{
-    error("Unsupported opcode %0*x in %s", (op > 0xff) ? 4 : 2, op, name);
-}
-
-/* Mark len bytes as scanned,  Returns insn_size + len.  Reports an error
-   if these bytes have already been scanned.  */
-static int
-eat_bytes(const char *name, char *flags, int insn, int insn_size, int len)
-{
-    while (len > 0) {
-        /* This should never occur in sane code.  */
-        if (flags[insn + insn_size] & FLAG_SCANNED)
-            error ("Overlapping instructions in %s", name);
-        flags[insn + insn_size] |= FLAG_SCANNED;
-        insn_size++;
-        len--;
-    }
-    return insn_size;
-}
-
-static void
-trace_i386_insn (const char *name, uint8_t *start_p, char *flags, int insn,
-                 int len)
-{
-    uint8_t *ptr;
-    uint8_t op;
-    int modrm;
-    int is_prefix;
-    int op_size;
-    int addr_size;
-    int insn_size;
-    int is_ret;
-    int is_condjmp;
-    int is_jmp;
-    int is_exit;
-    int is_pcrel;
-    int is_stack;
-    int immed;
-    int seen_rexw;
-    int32_t disp;
-
-    ptr = start_p + insn;
-    /* nonzero if this insn has a ModR/M byte.  */
-    modrm = 1;
-    /* The size of the immediate value in this instruction.  */
-    immed = 0;
-    /* The operand size.  */
-    op_size = 4;
-    /* The address size */
-    addr_size = 4;
-    /* The total length of this instruction.  */
-    insn_size = 0;
-    is_prefix = 1;
-    is_ret = 0;
-    is_condjmp = 0;
-    is_jmp = 0;
-    is_exit = 0;
-    seen_rexw = 0;
-    is_pcrel = 0;
-    is_stack = 0;
-
-    while (is_prefix) {
-        op = ptr[insn_size];
-        insn_size = eat_bytes(name, flags, insn, insn_size, 1);
-        is_prefix = 0;
-        switch (op >> 4) {
-        case 0:
-        case 1:
-        case 2:
-        case 3:
-            if (op == 0x0f) {
-                /* two-byte opcode.  */
-                op = ptr[insn_size];
-                insn_size = eat_bytes(name, flags, insn, insn_size, 1);
-                switch (op >> 4) {
-                case 0:
-                    if ((op & 0xf) > 3)
-                      modrm = 0;
-                    break;
-                case 1: /* vector move or prefetch */
-                case 2: /* various moves and vector compares.  */
-                case 4: /* cmov */
-                case 5: /* vector instructions */
-                case 6:
-                case 13:
-                case 14:
-                case 15:
-                    break;
-                case 7: /* mmx */
-                    if (op & 0x77) /* emms */
-                      modrm = 0;
-                    break;
-                case 3: /* wrmsr, rdtsc, rdmsr, rdpmc, sysenter, sysexit */
-                    modrm = 0;
-                    break;
-                case 8: /* long conditional jump */
-                    is_condjmp = 1;
-                    immed = op_size;
-                    modrm = 0;
-                    break;
-                case 9: /* setcc */
-                    break;
-                case 10:
-                    switch (op & 0x7) {
-                    case 0: /* push fs/gs */
-                    case 1: /* pop fs/gs */
-                        is_stack = 1;
-                    case 2: /* cpuid/rsm */
-                        modrm = 0;
-                        break;
-                    case 4: /* shld/shrd immediate */
-                        immed = 1;
-                        break;
-                    default: /* Normal instructions with a ModR/M byte.  */
-                        break;
-                    }
-                    break;
-                case 11:
-                    switch (op & 0xf) {
-                    case 10: /* bt, bts, btr, btc */
-                        immed = 1;
-                        break;
-                    default:
-                        /* cmpxchg, lss, btr, lfs, lgs, movzx, btc, bsf, bsr
-                           undefined, and movsx */
-                        break;
-                    }
-                    break;
-                case 12:
-                    if (op & 8) {
-                        /* bswap */
-                        modrm = 0;
-                    } else {
-                        switch (op & 0x7) {
-                        case 2:
-                        case 4:
-                        case 5:
-                        case 6:
-                            immed = 1;
-                            break;
-                        default:
-                            break;
-                        }
-                    }
-                    break;
-                }
-            } else if ((op & 0x07) <= 0x3) {
-                /* General arithmentic ax.  */
-            } else if ((op & 0x07) <= 0x5) {
-                /* General arithmetic ax, immediate.  */
-                if (op & 0x01)
-                    immed = op_size;
-                else
-                    immed = 1;
-                modrm = 0;
-            } else if ((op & 0x23) == 0x22) {
-                /* Segment prefix.  */
-                is_prefix = 1;
-            } else {
-                /* Segment register push/pop or DAA/AAA/DAS/AAS.  */
-                modrm = 0;
-            }
-            break;
-
-#if defined(HOST_X86_64)
-        case 4: /* rex prefix.  */
-            is_prefix = 1;
-            /* The address/operand size is actually 64-bit, but the immediate
-               values in the instruction are still 32-bit.  */
-            op_size = 4;
-            addr_size = 4;
-            if (op & 8)
-                seen_rexw = 1;
-            break;
-#else
-        case 4: /* inc/dec register.  */
-#endif
-        case 5: /* push/pop general register.  */
-            modrm = 0;
-            is_stack = 1;
-            break;
-
-        case 6:
-            switch (op & 0x0f) {
-            case 0: /* pusha */
-            case 1: /* popa */
-                modrm = 0;
-                is_stack = 1;
-                break;
-            case 2: /* bound */
-            case 3: /* arpl */
-                break;
-            case 4: /* FS */
-            case 5: /* GS */
-                is_prefix = 1;
-                break;
-            case 6: /* opcode size prefix.  */
-                op_size = 2;
-                is_prefix = 1;
-                break;
-            case 7: /* Address size prefix.  */
-                addr_size = 2;
-                is_prefix = 1;
-                break;
-            case 8: /* push immediate */
-                immed = op_size;
-                modrm = 0;
-                is_stack = 1;
-                break;
-            case 10: /* push 8-bit immediate */
-                immed = 1;
-                modrm = 0;
-                is_stack = 1;
-                break;
-            case 9: /* imul immediate */
-                immed = op_size;
-                break;
-            case 11: /* imul 8-bit immediate */
-                immed = 1;
-                break;
-            case 12: /* insb */
-            case 13: /* insw */
-            case 14: /* outsb */
-            case 15: /* outsw */
-                modrm = 0;
-                break;
-            }
-            break;
-
-        case 7: /* Short conditional jump.  */
-            is_condjmp = 1;
-            immed = 1;
-            modrm = 0;
-            break;
-          
-        case 8:
-            if ((op & 0xf) <= 3) {
-                /* arithmetic immediate.  */
-                if ((op & 3) == 1)
-                    immed = op_size;
-                else
-                    immed = 1;
-                if (op == 0x81 || op == 0x83) {
-                    /* add, sub */
-                    op = ptr[insn_size];
-                    switch ((op >> 3) & 7) {
-                    case 0:
-                    case 5:
-                        is_stack = (op & 7) == 4;
-                        break;
-                    }
-                }
-            }
-            else if ((op & 0xf) == 0xf) {
-                /* pop general.  */
-                is_stack = 1;
-            }
-            /* else test, xchg, mov, lea.  */
-            break;
-
-        case 9:
-            /* Various single-byte opcodes with no modrm byte.  */
-            modrm = 0;
-            if (op == 10) {
-                /* Call */
-                immed = 4;
-            }
-            break;
-
-        case 10:
-            switch ((op & 0xe) >> 1) {
-            case 0: /* mov absoliute immediate.  */
-            case 1:
-                if (seen_rexw)
-                    immed = 8;
-                else
-                    immed = addr_size;
-                break;
-            case 4: /* test immediate.  */
-                if (op & 1)
-                    immed = op_size;
-                else
-                    immed = 1;
-                break;
-            default: /* Various string ops.  */
-                break;
-            }
-            modrm = 0;
-            break;
-
-        case 11: /* move immediate to register */
-            if (op & 8) {
-                if (seen_rexw)
-                    immed = 8;
-                else
-                    immed = op_size;
-            } else {
-                immed = 1;
-            }
-            modrm = 0;
-            break;
-
-          case 12:
-            switch (op & 0xf) {
-            case 0: /* shift immediate */
-            case 1:
-                immed = 1;
-                break;
-            case 2: /* ret immediate */
-                immed = 2;
-                modrm = 0;
-                bad_opcode(name, op);
-                break;
-            case 3: /* ret */
-                modrm = 0;
-                is_ret = 1;
-            case 4: /* les */
-            case 5: /* lds */
-                break;
-            case 6: /* mov immediate byte */
-                immed = 1;
-                break;
-            case 7: /* mov immediate */
-                immed = op_size;
-                break;
-            case 8: /* enter */
-                /* TODO: Is this right?  */
-                immed = 3;
-                modrm = 0;
-                break;
-            case 10: /* retf immediate */
-                immed = 2;
-                modrm = 0;
-                bad_opcode(name, op);
-                break;
-            case 13: /* int */
-                immed = 1;
-                modrm = 0;
-                break;
-            case 11: /* retf */
-            case 15: /* iret */
-                modrm = 0;
-                bad_opcode(name, op);
-                break;
-            default: /* leave, int3 or into */
-                modrm = 0;
-                break;
-            }
-            break;
-
-        case 13:
-            if ((op & 0xf) >= 8) {
-                /* Coprocessor escape.  For our purposes this is just a normal
-                   instruction with a ModR/M byte.  */
-            } else if ((op & 0xf) >= 4) {
-                /* AAM, AAD or XLAT */
-                modrm = 0;
-            }
-            /* else shift instruction */
-            break;
-
-        case 14:
-            switch ((op & 0xc) >> 2) {
-            case 0: /* loop or jcxz */
-                is_condjmp = 1;
-                immed = 1;
-                break;
-            case 1: /* in/out immed */
-                immed = 1;
-                break;
-            case 2: /* call or jmp */
-                switch (op & 3) {
-                case 0: /* call */
-                    immed = op_size;
-                    break;
-                case 1: /* long jump */
-                    immed = 4;
-                    is_jmp = 1;
-                    break;
-                case 2: /* far jmp */
-                    bad_opcode(name, op);
-                    break;
-                case 3: /* short jmp */
-                    immed = 1;
-                    is_jmp = 1;
-                    break;
-                }
-                break;
-            case 3: /* in/out register */
-                break;
-            }
-            modrm = 0;
-            break;
-
-        case 15:
-            switch ((op & 0xe) >> 1) {
-            case 0:
-            case 1:
-                is_prefix = 1;
-                break;
-            case 2:
-            case 4:
-            case 5:
-            case 6:
-                modrm = 0;
-                /* Some privileged insns are used as markers.  */
-                switch (op) {
-                case 0xf4: /* hlt: Exit translation block.  */
-                    is_exit = 1;
-                    break;
-                case 0xfa: /* cli: Jump to label.  */
-                    is_exit = 1;
-                    immed = 4;
-                    break;
-                case 0xfb: /* sti: TB patch jump.  */
-                    /* Mark the insn for patching, but continue sscanning.  */
-                    flags[insn] |= FLAG_EXIT;
-                    immed = 4;
-                    break;
-                }
-                break;
-            case 3: /* unary grp3 */
-                if ((ptr[insn_size] & 0x38) == 0) {
-                    if (op == 0xf7)
-                        immed = op_size;
-                    else
-                        immed = 1; /* test immediate */
-                }
-                break;
-            case 7: /* inc/dec grp4/5 */
-                /* TODO: This includes indirect jumps.  We should fail if we
-                   encounter one of these. */
-                break;
-            }
-            break;
-        }
-    }
-
-    if (modrm) {
-        if (addr_size != 4)
-            error("16-bit addressing mode used in %s", name);
-
-        disp = 0;
-        modrm = ptr[insn_size];
-        insn_size = eat_bytes(name, flags, insn, insn_size, 1);
-        modrm &= 0xc7;
-        switch ((modrm & 0xc0) >> 6) {
-        case 0:
-            if (modrm == 5)
-              disp = 4;
-            break;
-        case 1:
-            disp = 1;
-            break;
-        case 2:
-            disp = 4;
-            break;
-        }
-        if ((modrm & 0xc0) != 0xc0 && (modrm & 0x7) == 4) {
-            /* SIB byte */
-            if (modrm == 4 && (ptr[insn_size] & 0x7) == 5) {
-                disp = 4;
-                is_pcrel = 1;
-            }
-            insn_size = eat_bytes(name, flags, insn, insn_size, 1);
-        }
-        insn_size = eat_bytes(name, flags, insn, insn_size, disp);
-    }
-    insn_size = eat_bytes(name, flags, insn, insn_size, immed);
-    if (is_condjmp || is_jmp) {
-        if (immed == 1) {
-            disp = (int8_t)*(ptr + insn_size - 1);
-        } else {
-            disp = (((int32_t)*(ptr + insn_size - 1)) << 24)
-                   | (((int32_t)*(ptr + insn_size - 2)) << 16)
-                   | (((int32_t)*(ptr + insn_size - 3)) << 8)
-                   | *(ptr + insn_size - 4);
-        }
-        disp += insn_size;
-        /* Jumps to external symbols point to the address of the offset
-           before relocation.  */
-        /* ??? These are probably a tailcall.  We could fix them up by
-           replacing them with jmp to EOB + call, but it's easier to just
-           prevent the compiler generating them.  */
-        if (disp == 1)
-            error("Unconditional jump (sibcall?) in %s", name);
-        disp += insn;
-        if (disp < 0 || disp > len)
-            error("Jump outside instruction in %s", name);
-
-        if ((flags[disp] & (FLAG_INSN | FLAG_SCANNED)) == FLAG_SCANNED)
-            error("Overlapping instructions in %s", name);
-
-        flags[disp] |= (FLAG_INSN | FLAG_TARGET);
-        is_pcrel = 1; 
-    }
-    if (is_pcrel) {
-        /* Mark the following insn as a jump target.  This will stop
-           this instruction being moved.  */
-        flags[insn + insn_size] |= FLAG_TARGET;
-    }
-    if (is_ret)
-      flags[insn] |= FLAG_RET;
-
-    if (is_exit)
-      flags[insn] |= FLAG_EXIT;
-
-    if (is_stack)
-      flags[insn] |= FLAG_STACK;
-
-    if (!(is_jmp || is_ret || is_exit))
-      flags[insn + insn_size] |= FLAG_INSN;
-}
-
-/* Scan a function body.  Returns the position of the return sequence.
-   Sets *patch_bytes to the number of bytes that need to be copied from that
-   location.  If no patching is required (ie. the return is the last insn)
-   *patch_bytes will be set to -1.  *plen is the number of code bytes to copy.
- */
-static int trace_i386_op(const char * name, uint8_t *start_p, int *plen,
-                         int *patch_bytes, int *exit_addrs)
-{
-    char *flags;
-    int more;
-    int insn;
-    int retpos;
-    int bytes;
-    int num_exits;
-    int len;
-    int last_insn;
-    int stack_clobbered;
-
-    len = *plen;
-    flags = malloc(len + 1);
-    memset(flags, 0, len + 1);
-    flags[0] |= FLAG_INSN;
-    more = 1;
-    while (more) {
-        more = 0;
-        for (insn = 0; insn < len; insn++) {
-            if ((flags[insn] & (FLAG_INSN | FLAG_SCANNED)) == FLAG_INSN) {
-                trace_i386_insn(name, start_p, flags, insn, len);
-                more = 1;
-            }
-        }
-    }
-
-    /* Strip any unused code at the end of the function.  */
-    while (len > 0 && flags[len - 1] == 0)
-      len--;
-
-    retpos = -1;
-    num_exits = 0;
-    last_insn = 0;
-    stack_clobbered = 0;
-    for (insn = 0; insn < len; insn++) {
-        if (flags[insn] & FLAG_RET) {
-            /* ??? In theory it should be possible to handle multiple return
-               points.  In practice it's not worth the effort.  */
-            if (retpos != -1)
-                error("Multiple return instructions in %s", name);
-            retpos = insn;
-        }
-        if (flags[insn] & FLAG_EXIT) {
-            if (0 && stack_clobbered)
-                error("Stack clobbered in %s", name);
-            if (num_exits == MAX_EXITS)
-                error("Too many block exits in %s", name);
-            exit_addrs[num_exits] = insn;
-            num_exits++;
-        }
-        if (flags[insn] & FLAG_INSN)
-            last_insn = insn;
-        if (flags[insn] & FLAG_STACK)
-            stack_clobbered = 1;
-    }
-
-    exit_addrs[num_exits] = -1;
-    if (retpos == -1) {
-        if (num_exits == 0) {
-            error ("No return instruction found in %s", name);
-        } else {
-            retpos = len;
-            last_insn = len;
-        }
-    }
-    
-    /* If the return instruction is the last instruction we can just 
-       remove it.  */
-    if (retpos == last_insn)
-        *patch_bytes = -1;
-    else
-        *patch_bytes = 0;
-
-    /* Back up over any nop instructions.  */
-    while (retpos > 0
-           && (flags[retpos] & FLAG_TARGET) == 0
-           && (flags[retpos - 1] & FLAG_INSN) != 0
-           && start_p[retpos - 1] == 0x90) {
-        retpos--;
-    }
-
-    if (*patch_bytes == -1) {
-        *plen = retpos;
-        free (flags);
-        return retpos;
-    }
-    *plen = len;
-
-    /* The ret is in the middle of the function.  Find four more bytes that
-       so the ret can be replaced by a jmp. */
-    /* ??? Use a short jump where possible. */
-    bytes = 4;
-    insn = retpos + 1;
-    /* We can clobber everything up to the next jump target.  */
-    while (insn < len && bytes > 0 && (flags[insn] & FLAG_TARGET) == 0) {
-        insn++;
-        bytes--;
-    }
-    if (bytes > 0) {
-        /* ???: Strip out nop blocks.  */
-        /* We can't do the replacement without clobbering anything important.
-           Copy preceeding instructions(s) to give us some space.  */
-        while (retpos > 0) {
-            /* If this byte is the target of a jmp we can't move it.  */
-            if (flags[retpos] & FLAG_TARGET)
-                break;
-
-            (*patch_bytes)++;
-            bytes--;
-            retpos--;
-
-            /* Break out of the loop if we have enough space and this is either 
-               the first byte of an instruction or a pad byte.  */
-            if ((flags[retpos] & (FLAG_INSN | FLAG_SCANNED)) != FLAG_SCANNED
-                && bytes <= 0) {
-                break;
-            }
-        }
-    }
-
-    if (bytes > 0)
-        error("Unable to replace ret with jmp in %s\n", name);
-
-    free(flags);
-    return retpos;
-}
-
-#endif
-
 #define MAX_ARGS 3
 
 /* generate op code */
@@ -2115,11 +1442,6 @@
     uint8_t args_present[MAX_ARGS];
     const char *sym_name, *p;
     EXE_RELOC *rel;
-#if defined(HOST_I386) || defined(HOST_X86_64)
-    int patch_bytes;
-    int retpos;
-    int exit_addrs[MAX_EXITS];
-#endif
 
     /* Compute exact size excluding prologue and epilogue instructions.
      * Increment start_offset to skip epilogue instructions, then compute
@@ -2130,12 +1452,33 @@
     p_end = p_start + size;
     start_offset = offset;
 #if defined(HOST_I386) || defined(HOST_X86_64)
+#ifdef CONFIG_FORMAT_COFF
+    {
+        uint8_t *p;
+        p = p_end - 1;
+        if (p == p_start)
+            error("empty code for %s", name);
+        while (*p != 0xc3) {
+            p--;
+            if (p <= p_start)
+                error("ret or jmp expected at the end of %s", name);
+        }
+        copy_size = p - p_start;
+    }
+#else
     {
         int len;
         len = p_end - p_start;
-        retpos = trace_i386_op(name, p_start, &len, &patch_bytes, exit_addrs);
+        if (len == 0)
+            error("empty code for %s", name);
+        if (p_end[-1] == 0xc3) {
+            len--;
+        } else {
+            error("ret or jmp expected at the end of %s", name);
+        }
         copy_size = len;
     }
+#endif
 #elif defined(HOST_PPC)
     {
         uint8_t *p;
@@ -2367,13 +1710,6 @@
     }
 
     if (gen_switch == 2) {
-#if defined(HOST_I386) || defined(HOST_X86_64)
-        if (patch_bytes != -1)
-            copy_size += patch_bytes;
-#ifdef DEBUG_OP
-        copy_size += 2;
-#endif
-#endif
         fprintf(outfile, "DEF(%s, %d, %d)\n", name + 3, nb_args, copy_size);
     } else if (gen_switch == 1) {
 
@@ -2579,43 +1915,7 @@
 #error unsupport object format
 #endif
                 }
-               }
-                /* Replace the marker instructions with the actual opcodes.  */
-                for (i = 0; exit_addrs[i] != -1; i++) {
-                    int op;
-                    switch (p_start[exit_addrs[i]])
-                      {
-                      case 0xf4: op = 0xc3; break; /* hlt -> ret */
-                      case 0xfa: op = 0xe9; break; /* cli -> jmp */
-                      case 0xfb: op = 0xe9; break; /* sti -> jmp */
-                      default: error("Internal error");
-                      }
-                    fprintf(outfile, 
-                            "    *(uint8_t *)(gen_code_ptr + %d) = 0x%x;\n",
-                            exit_addrs[i], op);
                 }
-                /* Fix up the return instruction.  */
-                if (patch_bytes != -1) {
-                    if (patch_bytes) {
-                        fprintf(outfile, "    memcpy(gen_code_ptr + %d,"
-                                "gen_code_ptr + %d, %d);\n",
-                                copy_size, retpos, patch_bytes);
-                    }
-                    fprintf(outfile,
-                            "    *(uint8_t *)(gen_code_ptr + %d) = 0xe9;\n",
-                            retpos);
-                    fprintf(outfile,
-                            "    *(uint32_t *)(gen_code_ptr + %d) = 0x%x;\n",
-                            retpos + 1, copy_size - (retpos + 5));
-                    
-                    copy_size += patch_bytes;
-                }
-#ifdef DEBUG_OP
-                fprintf(outfile,
-                        "    *(uint16_t *)(gen_code_ptr + %d) = 0x9090;\n",
-                        copy_size);
-                copy_size += 2;
-#endif
             }
 #elif defined(HOST_X86_64)
             {
@@ -2649,42 +1949,6 @@
                     }
                 }
                 }
-                /* Replace the marker instructions with the actual opcodes.  */
-                for (i = 0; exit_addrs[i] != -1; i++) {
-                    int op;
-                    switch (p_start[exit_addrs[i]])
-                      {
-                      case 0xf4: op = 0xc3; break; /* hlt -> ret */
-                      case 0xfa: op = 0xe9; break; /* cli -> jmp */
-                      case 0xfb: op = 0xe9; break; /* sti -> jmp */
-                      default: error("Internal error");
-                      }
-                    fprintf(outfile, 
-                            "    *(uint8_t *)(gen_code_ptr + %d) = 0x%x;\n",
-                            exit_addrs[i], op);
-                }
-                /* Fix up the return instruction.  */
-                if (patch_bytes != -1) {
-                    if (patch_bytes) {
-                        fprintf(outfile, "    memcpy(gen_code_ptr + %d,"
-                                "gen_code_ptr + %d, %d);\n",
-                                copy_size, retpos, patch_bytes);
-                    }
-                    fprintf(outfile,
-                            "    *(uint8_t *)(gen_code_ptr + %d) = 0xe9;\n",
-                            retpos);
-                    fprintf(outfile,
-                            "    *(uint32_t *)(gen_code_ptr + %d) = 0x%x;\n",
-                            retpos + 1, copy_size - (retpos + 5));
-                    
-                    copy_size += patch_bytes;
-                }
-#ifdef DEBUG_OP
-                fprintf(outfile,
-                        "    *(uint16_t *)(gen_code_ptr + %d) = 0x9090;\n",
-                        copy_size);
-                copy_size += 2;
-#endif
             }
 #elif defined(HOST_PPC)
             {
Only in PFSEFI_for_patch: dyngen.c.orig
Only in PFSEFI_for_patch: dyngen.c.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/exec-all.h /Users/QGuan/Downloads/temu-1.0/exec-all.h
--- PFSEFI_for_patch/exec-all.h	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/exec-all.h	2009-11-23 12:38:07.000000000 -0700
@@ -317,15 +317,14 @@
 
 #elif defined(__i386__) && defined(USE_DIRECT_JUMP)
 
-/* we patch the jump instruction directly.  Use sti in place of the actual
-   jmp instruction so that dyngen can patch in the correct result.  */
+/* we patch the jump instruction directly */
 #define GOTO_TB(opname, tbparam, n)\
 do {\
     asm volatile (".section .data\n"\
 		  ASM_OP_LABEL_NAME(n, opname) ":\n"\
 		  ".long 1f\n"\
 		  ASM_PREVIOUS_SECTION \
-                  "sti;.long " ASM_NAME(__op_jmp) #n " - 1f\n"\
+                  "jmp " ASM_NAME(__op_jmp) #n "\n"\
 		  "1:\n");\
 } while (0)
 
Only in PFSEFI_for_patch: exec-all.h.orig
Only in PFSEFI_for_patch: exec-all.h.rej
Only in PFSEFI_for_patch: expectTemu.sh
Only in PFSEFI_for_patch: guest.log
diff --exclude=tracecap -ur PFSEFI_for_patch/host-utils.c /Users/QGuan/Downloads/temu-1.0/host-utils.c
--- PFSEFI_for_patch/host-utils.c	2016-06-29 13:57:33.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/host-utils.c	2009-11-23 12:38:07.000000000 -0700
@@ -50,7 +50,7 @@
 {
     uint32_t a0, a1, b0, b1;
     uint64_t v;
-    printf("-->n1\n");
+
     a0 = a;
     a1 = a >> 32;
 
@@ -75,7 +75,6 @@
 void mulu64 (uint64_t *plow, uint64_t *phigh, uint64_t a, uint64_t b)
 {
     mul64(plow, phigh, a, b);
-    printf("-->n2\n");
 #if defined(DEBUG_MULDIV)
     printf("mulu64: 0x%016llx * 0x%016llx = 0x%016llx%016llx\n",
            a, b, *phigh, *plow);
@@ -86,7 +85,6 @@
 void muls64 (uint64_t *plow, uint64_t *phigh, int64_t a, int64_t b)
 {
     int sa, sb;
-    printf("-->n3\n");
 
     sa = (a < 0);
     if (sa)
Only in PFSEFI_for_patch: i386-softmmu
Only in PFSEFI_for_patch: inject_type
Only in PFSEFI_for_patch: install
Only in PFSEFI_for_patch: install-fsefi.sh
Only in PFSEFI_for_patch: llconf
Only in PFSEFI_for_patch: llconf-0.4.6
Only in PFSEFI_for_patch: llconf-0.4.6.tar.gz
Only in PFSEFI_for_patch: llconf-0.4.6.tar.gz.1
diff --exclude=tracecap -ur PFSEFI_for_patch/monitor.c /Users/QGuan/Downloads/temu-1.0/monitor.c
--- PFSEFI_for_patch/monitor.c	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/monitor.c	2009-11-23 12:38:08.000000000 -0700
@@ -53,7 +53,6 @@
  * Supported types:
  *
  * 'F'          filename
- * 'b'		batch command -- by guanxyz
  * 'B'          block device name
  * 's'          string (accept optional quote)
  * 'i'          32 bit integer
@@ -780,174 +779,120 @@
 typedef struct {
     int keycode;
     const char *name;
-    int need_shift;
 } KeyDef;
 
 static const KeyDef key_defs[] = {
-    { 0x2a, "shift",0 },
-    { 0x36, "shift_r",0 },
+    { 0x2a, "shift" },
+    { 0x36, "shift_r" },
 
-    { 0x38, "alt", 0 },
-    { 0xb8, "alt_r", 0 },
-    { 0x1d, "ctrl", 0 },
-    { 0x9d, "ctrl_r", 0 },
-
-    { 0xdd, "menu", 0 },
-
-    { 0x01, "esc",0 },
-
-    { 0x02, "1",0 },
-    { 0x03, "2",0 },
-    { 0x04, "3",0 },
-    { 0x05, "4",0 },
-    { 0x06, "5",0 },
-    { 0x07, "6",0 },
-    { 0x08, "7",0 },
-    { 0x09, "8",0 },
-    { 0x0a, "9",0 },
-    { 0x0b, "0",0 },
-    { 0x0c, "minus",0 },
-    { 0x0d, "equal",0 },
-    { 0x0e, "backspace",0 },
-
-    { 0x0f, "tab",0 },
-    { 0x10, "q",0 },
-    { 0x11, "w",0 },
-    { 0x12, "e",0 },
-    { 0x13, "r",0 },
-    { 0x14, "t",0 },
-    { 0x15, "y",0 },
-    { 0x16, "u",0 },
-    { 0x17, "i",0 },
-    { 0x18, "o",0 },
-    { 0x19, "p",0 },
-    
-    { 0x10, "Q",1 },
-    { 0x11, "W",1 },
-    { 0x12, "E",1 },
-    { 0x13, "R",1 },
-    { 0x14, "T",1 },
-    { 0x15, "Y",1 },
-    { 0x16, "U",1 },
-    { 0x17, "I",1 },
-    { 0x18, "O",1 },
-    { 0x19, "P",1 },
-
-    { 0x1c, "ret",0 },
-
-    { 0x1e, "a",0 },
-    { 0x1f, "s",0 },
-    { 0x20, "d",0 },
-    { 0x21, "f",0 },
-    { 0x22, "g",0 },
-    { 0x23, "h",0 },
-    { 0x24, "j",0 },
-    { 0x25, "k",0 },
-    { 0x26, "l",0 },
-    
-    { 0x1e, "A",1 },
-    { 0x1f, "S",1 },
-    { 0x20, "D",1 },
-    { 0x21, "F",1 },
-    { 0x22, "G",1 },
-    { 0x23, "H",1 },
-    { 0x24, "J",1 },
-    { 0x25, "K",1 },
-    { 0x26, "L",1 },
-
-    { 0x2c, "z",0 },
-    { 0x2d, "x",0 },
-    { 0x2e, "c",0 },
-    { 0x2f, "v",0 },
-    { 0x30, "b",0 },
-    { 0x31, "n",0 },
-    { 0x32, "m",0 },
-    { 0x33, "comma",0},
-    { 0x34, "dot",0},
-    
-    { 0x2c, "Z",1 },
-    { 0x2d, "X",1 },
-    { 0x2e, "C",1 },
-    { 0x2f, "V",1 },
-    { 0x30, "B",1 },
-    { 0x31, "N",1 },
-    { 0x32, "M",1 },
-
-    { 0x33, ",", 0},
-    { 0x34, ".", 0},
-    { 0x35, "/", 0},
-    { 0x33, "<", 1},
-    { 0x34, ">", 1},
-    { 0x35, "?", 1},
-
-    { 0x39, "spc",0 },
-    { 0x39, " ",0 },
-    { 0x3a, "caps_lock",0 },
-    { 0x3b, "f1",0 },
-    { 0x3c, "f2",0 },
-    { 0x3d, "f3",0 },
-    { 0x3e, "f4",0 },
-    { 0x3f, "f5",0 },
-    { 0x40, "f6",0 },
-    { 0x41, "f7",0 },
-    { 0x42, "f8",0 },
-    { 0x43, "f9",0 },
-    { 0x44, "f10",0 },
-    { 0x45, "num_lock",0 },
-    { 0x46, "scroll_lock",0 },
-
-    { 0xb5, "kp_divide",0 },
-    { 0x37, "kp_multiply",0 },
-    { 0x4a, "kp_subtract",0 },
-    { 0x4e, "kp_add",0 },
-    { 0x9c, "kp_enter",0 },
-    { 0x53, "kp_decimal",0 },
-
-    { 0x52, "kp_0",0 },
-    { 0x4f, "kp_1",0 },
-    { 0x50, "kp_2",0 },
-    { 0x51, "kp_3",0 },
-    { 0x4b, "kp_4",0 },
-    { 0x4c, "kp_5",0 },
-    { 0x4d, "kp_6",0 },
-    { 0x47, "kp_7",0 },
-    { 0x48, "kp_8",0 },
-    { 0x49, "kp_9",0 },
-
-    { 0x56, "<",0 },
-
-    { 0x57, "f11",0 },
-    { 0x58, "f12",0 },
-
-    { 0xb7, "print",0 },
-
-    { 0xc7, "home",0 },
-    { 0xc9, "pgup",0 },
-    { 0xd1, "pgdn",0 },
-    { 0xcf, "end",0 },
-
-    { 0xcb, "left",0 },
-    { 0xc8, "up",0 },
-    { 0xd0, "down",0 },
-    { 0xcd, "right",0 },
-
-    { 0xd2, "insert",0 },
-    { 0xd3, "delete",0 },
-	
-    { 0x02, "!", 1},
-    { 0x03, "@", 1},
-    { 0x04, "#", 1},
-    { 0x05, "$", 1},
-    { 0x06, "%", 1},
-    { 0x07, "^", 1},
-    { 0x08, "&", 1},
-    { 0x09, "*", 1},
-    { 0x0a, "(", 1},
-    { 0x0b, ")", 1},
-	{ 0x0c, "_", 1},
-    { 0x27, ":", 1},
-
-    { 0, NULL, 0 },
+    { 0x38, "alt" },
+    { 0xb8, "alt_r" },
+    { 0x1d, "ctrl" },
+    { 0x9d, "ctrl_r" },
+
+    { 0xdd, "menu" },
+
+    { 0x01, "esc" },
+
+    { 0x02, "1" },
+    { 0x03, "2" },
+    { 0x04, "3" },
+    { 0x05, "4" },
+    { 0x06, "5" },
+    { 0x07, "6" },
+    { 0x08, "7" },
+    { 0x09, "8" },
+    { 0x0a, "9" },
+    { 0x0b, "0" },
+    { 0x0c, "minus" },
+    { 0x0d, "equal" },
+    { 0x0e, "backspace" },
+
+    { 0x0f, "tab" },
+    { 0x10, "q" },
+    { 0x11, "w" },
+    { 0x12, "e" },
+    { 0x13, "r" },
+    { 0x14, "t" },
+    { 0x15, "y" },
+    { 0x16, "u" },
+    { 0x17, "i" },
+    { 0x18, "o" },
+    { 0x19, "p" },
+
+    { 0x1c, "ret" },
+
+    { 0x1e, "a" },
+    { 0x1f, "s" },
+    { 0x20, "d" },
+    { 0x21, "f" },
+    { 0x22, "g" },
+    { 0x23, "h" },
+    { 0x24, "j" },
+    { 0x25, "k" },
+    { 0x26, "l" },
+
+    { 0x2c, "z" },
+    { 0x2d, "x" },
+    { 0x2e, "c" },
+    { 0x2f, "v" },
+    { 0x30, "b" },
+    { 0x31, "n" },
+    { 0x32, "m" },
+
+    { 0x39, "spc" },
+    { 0x3a, "caps_lock" },
+    { 0x3b, "f1" },
+    { 0x3c, "f2" },
+    { 0x3d, "f3" },
+    { 0x3e, "f4" },
+    { 0x3f, "f5" },
+    { 0x40, "f6" },
+    { 0x41, "f7" },
+    { 0x42, "f8" },
+    { 0x43, "f9" },
+    { 0x44, "f10" },
+    { 0x45, "num_lock" },
+    { 0x46, "scroll_lock" },
+
+    { 0xb5, "kp_divide" },
+    { 0x37, "kp_multiply" },
+    { 0x4a, "kp_subtract" },
+    { 0x4e, "kp_add" },
+    { 0x9c, "kp_enter" },
+    { 0x53, "kp_decimal" },
+
+    { 0x52, "kp_0" },
+    { 0x4f, "kp_1" },
+    { 0x50, "kp_2" },
+    { 0x51, "kp_3" },
+    { 0x4b, "kp_4" },
+    { 0x4c, "kp_5" },
+    { 0x4d, "kp_6" },
+    { 0x47, "kp_7" },
+    { 0x48, "kp_8" },
+    { 0x49, "kp_9" },
+
+    { 0x56, "<" },
+
+    { 0x57, "f11" },
+    { 0x58, "f12" },
+
+    { 0xb7, "print" },
+
+    { 0xc7, "home" },
+    { 0xc9, "pgup" },
+    { 0xd1, "pgdn" },
+    { 0xcf, "end" },
+
+    { 0xcb, "left" },
+    { 0xc8, "up" },
+    { 0xd0, "down" },
+    { 0xcd, "right" },
+
+    { 0xd2, "insert" },
+    { 0xd3, "delete" },
+    { 0, NULL },
 };
 
 static int get_keycode(const char *key)
@@ -968,69 +913,6 @@
     return -1;
 }
 
-static int is_shift_needed(const char *key){
-  const KeyDef *p;
-
-  for(p = key_defs; p->name!=NULL; p++){
-    if(!strcmp(key, p->name))
-      return p->need_shift;
-  }
-  return 0;
-}
-
-#ifdef _TEMU_MAIN_H_INCLUDED_
-void do_send_string(const char *str)
-#else
-static void do_send_string(const char *str)
-#endif
-{
-  char keybuf[2];
-  const char *p = str;
-  int keycode;
-
-  keybuf[0] = '\0';
-  keybuf[1] = '\0';
-
-  while(*p != '\0'){
-    keybuf[0] = *p;
-    keycode = get_keycode(keybuf);
-
-    int shift_need = is_shift_needed(keybuf);
-
-    if(keycode<0){
-      term_printf("unknown key: '%s' \n", keybuf);
-      return;
-    }
-
-    if(shift_need){
-      kbd_put_keycode(0x2a & 0x7f);
-    }
-    
-    // Key down event
-    if(keycode & 0x80)
-      kbd_put_keycode(0xe0);
-
-    kbd_put_keycode(keycode & 0x7f);  
-
-    // Key up event
-    if(keycode & 0x80)
-      kbd_put_keycode(0x0e);
-
-    kbd_put_keycode(keycode | 0x80);  
-      
-    // Release the SHIFT key
-    if(shift_need)
-      kbd_put_keycode(0x2a | 0x80);
-
-    // go for next char
-    p++;
-     
-  }
-
-
-}
-
-
 #ifdef _TEMU_MAIN_H_INCLUDED_
 void do_send_key(const char *string)
 #else
@@ -1038,7 +920,7 @@
 #endif
 {
     char keybuf[16], *q;
-    uint8_t keycodes[64];
+    uint8_t keycodes[16];
     const char *p;
     int nb_keycodes, keycode, i;
 
@@ -1046,7 +928,6 @@
     p = string;
     while (*p != '\0') {
         q = keybuf;
-
         while (*p != '\0' && *p != '-') {
             if ((q - keybuf) < sizeof(keybuf) - 1) {
                 *q++ = *p;
@@ -1474,11 +1355,6 @@
       "", "TEMU command: enable emulation (disable virtualization mode)"},
     { "disable_emulation", "", do_disable_emulation,
       "", "TEMU command: disable emulation (switch to virtualization mode)"},
-    { "reboot_SEFI", "", do_reboot_SEFI,
-      "", "SEFI command: Reboot SEFI module", },
-    { "send_string",  "b", do_send_string,
-     "string", "send string to Guest "},
-      
     { NULL, NULL, },
 };
 
@@ -2292,25 +2168,6 @@
                 args[nb_args++] = str;
             }
             break;
-	
-	case 'b':    // Special type for batch 
-	    { 
-                char *str;
-		strcpy(buf, p);
-
-		str = qemu_malloc(strlen(buf) + 1);
-                strcpy(str, buf);
-                str_allocated[nb_args] = str;
-                
-		args[nb_args++] = str;
-	        
-	        
-		while (*p != '\0')
-                    p++;
-
-	    }
-	    break;    
-	    
         case '/':
             {
                 int count, format, size;
@@ -2752,7 +2609,7 @@
 
 static void monitor_start_input(void)
 {
-    readline_start("(SEFI) ", 0, monitor_handle_command1, NULL);
+    readline_start("(qemu) ", 0, monitor_handle_command1, NULL);
 }
 
 static void term_event(void *opaque, int event)
@@ -2761,7 +2618,7 @@
 	return;
 
     if (!hide_banner)
-	    term_printf("SEFI(QEMU %s) monitor - type 'help' for more information\n",
+	    term_printf("QEMU %s monitor - type 'help' for more information\n",
 			QEMU_VERSION);
     monitor_start_input();
 }
Only in PFSEFI_for_patch: mytest
Only in PFSEFI_for_patch: plugin.log
Only in PFSEFI_for_patch: probability.txt
Only in PFSEFI_for_patch: qemu-doc.html
Only in PFSEFI_for_patch: qemu-img.1
Only in PFSEFI_for_patch: qemu-tech.html
Only in PFSEFI_for_patch: qemu.1
Only in PFSEFI_for_patch: qemuVM.sh
Only in PFSEFI_for_patch: qemuVM_clamr.sh
Only in PFSEFI_for_patch: qemuVM_sorting.sh
Only in PFSEFI_for_patch: qemuVM_srad.sh
diff --exclude=tracecap -ur PFSEFI_for_patch/sample_plugin/main.c /Users/QGuan/Downloads/temu-1.0/sample_plugin/main.c
--- PFSEFI_for_patch/sample_plugin/main.c	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/sample_plugin/main.c	2009-11-23 12:38:10.000000000 -0700
@@ -138,16 +138,15 @@
   mi = locate_module(eip, cr3, current_proc); 
 
   should_monitor = (strcasecmp(current_proc, monitored_proc) == 0);
-  if (!should_monitor){
+  if (!should_monitor)
     goto finished;
-  }
+
   fprintf(my_log, "block_begin: eip=%08x\n", eip);
 
 finished:
   //we should always check if there is a hook at this point, 
   //no matter we are in the monitored context or not, because 
   //some hooks are global.
-  
   hookapi_check_call(should_monitor);
   return 0;
 }
@@ -161,7 +160,7 @@
   //now we can analyze this instruction
   uint32_t eip;
   TEMU_read_register(eip_reg, &eip);
- // fprintf(my_log, "insn_begin: eip=%08x\n", eip);  
+  fprintf(my_log, "insn_begin: eip=%08x\n", eip);  
 }
 
 //This callback is invoked for every keystroke
Only in PFSEFI_for_patch/sample_plugin: main.d
Only in PFSEFI_for_patch/sample_plugin: main.o
Only in PFSEFI_for_patch/sample_plugin: network.d
Only in PFSEFI_for_patch/sample_plugin: network.o
Only in PFSEFI_for_patch/sample_plugin: plugin.so
Only in PFSEFI_for_patch/sample_plugin: tags
Only in PFSEFI_for_patch/sample_plugin: temu
diff --exclude=tracecap -ur PFSEFI_for_patch/shared/disasm.h /Users/QGuan/Downloads/temu-1.0/shared/disasm.h
--- PFSEFI_for_patch/shared/disasm.h	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/shared/disasm.h	2009-11-23 12:38:18.000000000 -0700
@@ -20,7 +20,6 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <stdint.h>
-#define PACKAGE "PFSEFI"
 #include <bfd.h>
 
 #ifdef __cplusplus
Only in PFSEFI_for_patch/shared: llconf
Only in PFSEFI_for_patch/shared: llconf-0.4.6
Only in PFSEFI_for_patch/shared: llconf-0.4.6.tar.gz
diff --exclude=tracecap -ur PFSEFI_for_patch/shared/procmod.cpp /Users/QGuan/Downloads/temu-1.0/shared/procmod.cpp
--- PFSEFI_for_patch/shared/procmod.cpp	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/shared/procmod.cpp	2009-11-23 12:38:16.000000000 -0700
@@ -390,41 +390,6 @@
   }
 }
 
-uint8_t SEFI_targetps_flag = 0;
-int SEFI_check_target_ps(char *progname){
-    uint32_t nextaddr = 0; 
-
-    char comm[512]; 
-    
-    if(strcmp(progname, "")==0)
-      return 0;
-    if (0 == taskaddr) 
-	init_kernel_offsets(); 
-
-    nextaddr = taskaddr; 
-    do {
-	get_name(nextaddr, comm, 512); 
-	//term_printf("%s (%d)\n", comm, SEFI_targetps_flag); 
-
-	if(strcmp((char *)&comm[0], progname)==0) {
-	  if(SEFI_targetps_flag==0){
-	    SEFI_targetps_flag = 1;
-	  }
-	  return 1; // Target ps is running
-	}
-	
-	nextaddr = next_task_struct(nextaddr); 
-
-    } while (nextaddr != taskaddr);
-    if(SEFI_targetps_flag == 1){
-      SEFI_targetps_flag = 0;
-      //term_printf("target process %s exits!!\n", progname); 
-      return 2;    //target ps is no longer running.
-    }
-	
-    return 0;  // No further action based on this.....
-
-}
 
 void do_linux_ps()
 {
@@ -442,11 +407,8 @@
 	pid = get_pid(nextaddr); 
 	pgd = get_pgd(nextaddr); 
 	get_name(nextaddr, comm, 512); 
-
-	// test by Guan
 	
-//	if(strcmp((char *)&comm[0], "test")==0){
-//	term_printf("%10d  CR3=0x%08lX  %s\n", pid, pgd-0xC0000000, comm); 
+	term_printf("%10d  CR3=0x%08lX  %s\n", pid, pgd-0xC0000000, comm); 
 	mmap = get_first_mmap(nextaddr); 
 	while (0 != mmap) {
 	    get_mod_name(mmap, comm, 512); 
@@ -454,7 +416,6 @@
 			get_vmstart(mmap),
 			get_vmend(mmap), comm); 
 	    mmap = get_next_mmap(mmap); 
-//	}
 	}
 	
 	nextaddr = next_task_struct(nextaddr); 
diff --exclude=tracecap -ur PFSEFI_for_patch/shared/procmod.h /Users/QGuan/Downloads/temu-1.0/shared/procmod.h
--- PFSEFI_for_patch/shared/procmod.h	2016-06-29 13:57:34.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/shared/procmod.h	2009-11-23 12:38:15.000000000 -0700
@@ -94,9 +94,6 @@
 void parse_process(char *log);
 void parse_module(char *log);
 
-int SEFI_check_target_ps(char *proname);
-extern uint8_t SEFI_targetps_flag;
-
 /// @ingroup semantics
 /// This function is only used to update process and module information for Linux
 int update_proc(void *opaque);
Only in PFSEFI_for_patch/shared: sleuthkit
Only in PFSEFI_for_patch/shared: sleuthkit-2.04
Only in PFSEFI_for_patch/shared: sleuthkit-2.04.patch
Only in PFSEFI_for_patch/shared: sleuthkit-2.04.tar.gz
Only in PFSEFI_for_patch/shared: sleuthkit-linux3.patch
diff --exclude=tracecap -ur PFSEFI_for_patch/softmmu_header.h /Users/QGuan/Downloads/temu-1.0/softmmu_header.h
--- PFSEFI_for_patch/softmmu_header.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/softmmu_header.h	2009-11-23 12:38:07.000000000 -0700
@@ -86,7 +86,7 @@
 #endif
 
 #if (DATA_SIZE <= 4) && (TARGET_LONG_BITS == 32) && defined(__i386__) && \
-    (ACCESS_TYPE < NB_MMU_MODES) && defined(ASM_SOFTMMU) && (__GNUC__ < 4) && (TAINT_ENABLED==0)
+    (ACCESS_TYPE < NB_MMU_MODES) && defined(ASM_SOFTMMU) && (TAINT_ENABLED==0)
 
 #define CPU_TLB_ENTRY_BITS 4
 
@@ -128,7 +128,7 @@
                   "m" (*(uint32_t *)offsetof(CPUState, tlb_table[CPU_MMU_INDEX][0].addr_read)),
                   "i" (CPU_MMU_INDEX),
                   "m" (*(uint8_t *)&glue(glue(__ld, SUFFIX), MMUSUFFIX))
-                  : "%eax", "%edx", "memory", "cc");
+                  : "%eax", "%ecx", "%edx", "memory", "cc");
     return res;
 }
 
@@ -175,14 +175,13 @@
                   "m" (*(uint32_t *)offsetof(CPUState, tlb_table[CPU_MMU_INDEX][0].addr_read)),
                   "i" (CPU_MMU_INDEX),
                   "m" (*(uint8_t *)&glue(glue(__ld, SUFFIX), MMUSUFFIX))
-                  : "%eax", "%edx", "memory", "cc");
+                  : "%eax", "%ecx", "%edx", "memory", "cc");
     return res;
 }
 #endif
 
-static inline void glue(glue(st, SUFFIX), MEMSUFFIX)(target_ulong ptr, RES_TYPE val)
+static inline void glue(glue(st, SUFFIX), MEMSUFFIX)(target_ulong ptr, RES_TYPE v)
 {
-    RES_TYPE v = val;
     asm volatile ("movl %0, %%edx\n"
                   "movl %0, %%eax\n"
                   "shrl %3, %%edx\n"
@@ -219,14 +218,16 @@
                   "2:\n"
                   :
                   : "r" (ptr),
-                  "q" (v),
+/* NOTE: 'q' would be needed as constraint, but we could not use it
+   with T1 ! */
+                  "r" (v),
                   "i" ((CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS),
                   "i" (TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS),
                   "i" (TARGET_PAGE_MASK | (DATA_SIZE - 1)),
                   "m" (*(uint32_t *)offsetof(CPUState, tlb_table[CPU_MMU_INDEX][0].addr_write)),
                   "i" (CPU_MMU_INDEX),
                   "m" (*(uint8_t *)&glue(glue(__st, SUFFIX), MMUSUFFIX))
-                  : "%eax", "%edx", "memory", "cc");
+                  : "%eax", "%ecx", "%edx", "memory", "cc");
 }
 
 #else
Only in PFSEFI_for_patch: softmmu_header.h.orig
Only in PFSEFI_for_patch: softmmu_header.h.rej
Only in PFSEFI_for_patch: startVM.sh
Only in PFSEFI_for_patch: startVMHPL.sh
Only in PFSEFI_for_patch: startnpbkvm.sh
Only in PFSEFI_for_patch: startnpbvm.sh
diff --exclude=tracecap -ur PFSEFI_for_patch/taintcheck.c /Users/QGuan/Downloads/temu-1.0/taintcheck.c
--- PFSEFI_for_patch/taintcheck.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/taintcheck.c	2009-11-23 12:38:10.000000000 -0700
@@ -36,14 +36,6 @@
 
 #define min(X,Y) ((X) < (Y) ? (X) : (Y))
 
-/*
- *  Only for FSEFI
- *
-*/ 
-
-int SEFI_helper_read_type_2_count(uint32_t type, uint64_t *p_curr, uint64_t *p_lower);
-int SEFI_helper_write_type_2_count(uint32_t type, uint64_t curr);
-
 /*!
  An internal data structure for holding 64-byte taint information in memory
  */
@@ -1803,889 +1795,5 @@
   term_printf("Tainted memory: %d \n", taintcheck_get_sizeof_taintmem());
 }
 
-/******************************************************************/
-/* Add injection functions	- by guanxyz 			  */
-/******************************************************************/
-void print_something(void){
-  if(cpu_single_env->is_inject_allowed 
-     && cpu_single_env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-
-    // printf("from taint--> %08lx\n", cpu_single_env->eip);
-  }
-}
-void print_something_t(int val){
-  if(cpu_single_env->is_inject_allowed 
-     && cpu_single_env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-
-   //  printf("from taint--> %08lx [%d]\n", cpu_single_env->eip, val);
-  }
-}
-
-#if 1
-// here ulobg == uint32
-//
-#define FI_ADD_OP 1
-#define FI_MUL_OP 2
-#define FI_CMP_OP 3
-#define FI_XOR_OP 4
-#define FI_SARL_OP 5
-#define FI_IDIVL_OP 6
-#define FI_IMUL_OP 7
-#define FI_IADDL_OP 8
-#define FI_ISUBL_OP 9
-#define FI_SHRL_OP 10
-#define FI_ANDL_OP 11
-#define FI_ORL_OP 12
-#define FI_XORL_OP 13
-#define FI_MOVL_OP 14
-#define FI_TESTL_OP 15
-#define FI_NOTL_OP 16
-#define FI_LD_OP 17
-
-#define FI_ADD_FAULTY_OP "FADD_OP"
-#define FI_MUL_FAULTY_OP "FMUL_OP"
-#define FI_CMP_FAULTY_OP "CMP_OP"
-#define FI_XOR_FAULTY_OP "XOR_OP"
-#define FI_SARL_FAULTY_OP "SARL_OP"
-#define FI_IDIVL_FAULTY_OP "IDVIL_OP"
-#define FI_IMUL_FAULTY_OP "IMUL_OP"
-#define FI_IADDL_FAULTY_OP "IADDL_OP"
-#define FI_ISUBL_FAULTY_OP "ISUBL_OP"
-#define FI_SHRL_FAULTY_OP "SHRL_OP"
-#define FI_ANDL_FAULTY_OP "ANDL_OP"
-#define FI_ORL_FAULTY_OP "ORL_OP"
-#define FI_XORL_FAULTY_OP "XORL_OP"
-#define FI_MOVL_FAULTY_OP "MOVL_OP"
-#define FI_TESTL_FAULTY_OP "TESTL_OP"
-#define FI_NOTL_FAULTY_OP "NOTL_OP"
-#define FI_LD_FAULTY_OP "LOAD_OP"
-
-#define CHECK_MEMORY_RANGE (cpu_single_env->eip>=cpu_single_env->inject_start_addr && cpu_single_env->eip<=cpu_single_env->inject_end_addr) ? 1:0
-
-int SEFI_helper_probability(int rate){
-   if (rate>=10)
-	return 0;
-   int j = rand()%10;
-   if (j>=rate)
-	return 1;
-   else
-	return 0;
-}
-
-
-
-// Check to turn off injector
-void SEFI_helper_turn_off_injector(uint32_t type){
-  if(cpu_single_env->counter==0){
-	cpu_single_env->is_inject_triggered = 0;
-	cpu_single_env->is_inject_allowed = 0;
-	SEFI_helper_write_type_2_count(type, 0);
-  }
-}
-
-// injection into uint32
-uint32_t SEFI_helper_bit_flip_uint32(uint32_t T0_reg, uint32_t op_type){
-   uint32_t j;
-   uint32_t flip, tmp;
-   uint64_t dic_count;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   // Get the pointer of ST0 to a unsigned long int para
-   tmp = T0_reg;
-   
-   // for random seed
-   base = cpu_single_env->start_bit; 
-   denom = (cpu_single_env->end_bit)+1 - cpu_single_env->start_bit;
-   
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < cpu_single_env->num_bit; iter++){   
-     j = rand()%denom+base;
-     flip = flip | (uint32_t)((uint32_t)1<<j);
-   }
-   tmp = tmp ^flip;
-   SEFI_helper_read_type_2_count(op_type, &dic_count, NULL);
-   printf("EIP:0x%08X(OP_Code:%d), Flip Mask: 0x%lx(seed:%d), Masked Register:0x%lx DIC : %lu \n",cpu_single_env->eip, op_type,flip, j, tmp, dic_count);
-   switch(op_type){
-     case FI_ADD_OP:
-        strcpy(str_type,FI_ADD_FAULTY_OP);
-     	break;
-     case FI_MUL_OP:
-        strcpy(str_type,FI_MUL_FAULTY_OP);
-     	break;
-     case FI_CMP_OP:
-        strcpy(str_type,FI_CMP_FAULTY_OP);
-     	break; 
-     case FI_XOR_OP:
-     	strcpy(str_type,FI_XOR_FAULTY_OP);
-	break;
-     case FI_SARL_OP:
-	strcpy(str_type,FI_SARL_FAULTY_OP);
-	break;
-     case FI_IDIVL_OP:
-	strcpy(str_type,FI_IDIVL_FAULTY_OP);
-	break;
-     case FI_IMUL_OP:
-	strcpy(str_type,FI_IMUL_FAULTY_OP);
-	break;
-     case FI_IADDL_OP:
-	strcpy(str_type,FI_IADDL_FAULTY_OP);
-	break;
-     case FI_ISUBL_OP:
-	strcpy(str_type,FI_ISUBL_FAULTY_OP);
-	break;
-     case FI_SHRL_OP:
-	strcpy(str_type,FI_SHRL_FAULTY_OP);
-	break;
-     case FI_ANDL_OP:
-	strcpy(str_type,FI_ANDL_FAULTY_OP);
-	break;
-     case FI_ORL_OP:
-	strcpy(str_type,FI_ORL_FAULTY_OP);
-	break;
-     case FI_XORL_OP:
-	strcpy(str_type,FI_XORL_FAULTY_OP);
-	break;
-     case FI_MOVL_OP:
-	strcpy(str_type,FI_MOVL_FAULTY_OP);
-	break;
-     case FI_TESTL_OP:
-	strcpy(str_type,FI_TESTL_FAULTY_OP);
-	break;
-     case FI_NOTL_OP:
-	strcpy(str_type,FI_NOTL_FAULTY_OP);
-	break;
-     default:
-        strcpy(str_type, "Unknown");
-     	break;	
-   }   
-   SEFI_writelog(cpu_single_env->func_name, "FaultyOp:%s,eip:0x%08lX, Original:%d, BitflipMask:%08lX, AfterInjection:%d, DynamicInstruction:%lu\n",
-                                  str_type,
-				  cpu_single_env->eip,
-				  (int32_t)T0_reg,
-				 // sizeof(T0_reg),
-				  flip,
-				  //sizeof(flip),
-				  (int32_t)tmp,
-				  //sizeof(tmp),
-				  dic_count
-   );
-   
-   return tmp;
-
-}
-
-
-#include <inttypes.h>  /* For uint128 */
-// fault injection func
-void SEFI_helper_bit_flip_double64(long double *ST0_reg, int op_type){
-   long int j;
-   unsigned __int128 flip, tmp;
-   uint64_t dic_count;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   long double reg = *ST0_reg;  // used for the whole injection 
-   			  // and finally will be copied back to ST0_reg
-   // Get the pointer of ST0 to a unsigned long int para
-   tmp = *((unsigned __int128 *)(&reg));
-   
-   // for random seed
-   base = cpu_single_env->start_bit; 
-   denom = cpu_single_env->end_bit - cpu_single_env->start_bit;
-   denom +=1;
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < cpu_single_env->num_bit; iter++){   
-     j = rand()%denom+base;
-     // bit flip
-     // For multiple flips 
-     flip = flip | (unsigned __int128)((unsigned __int128)1<<j);
-   }
-   tmp = tmp ^flip;
-   SEFI_helper_read_type_2_count(op_type, &dic_count, NULL);
-   printf("EIP: 0x%08X, Flip Mask: 0x%016"PRIx64"%016"PRIx64", BeforeInjection:%Lf (0x%016"PRIx64"%016"PRIx64"), AfterInjection:%Lf(0x%016"PRIx64"%016"PRIx64"),  DIC:%lu\n", 
-       cpu_single_env->eip, 
-       (uint64_t)(flip>>64),(uint64_t)flip,
-       (long double)reg, 
-        (uint64_t)(*((unsigned __int128 *)(&reg))>>64),(uint64_t)*((unsigned __int128 *)(&reg)), 
-       *((long double *)(&tmp)), 
-       (uint64_t)(tmp>>64),(uint64_t)tmp, 
-       dic_count
-       );
-    switch(op_type){
-     case FI_ADD_OP:
-        strcpy(str_type,FI_ADD_FAULTY_OP);
-     	break;
-     case FI_MUL_OP:
-        strcpy(str_type,FI_MUL_FAULTY_OP);
-     	break;
-     case FI_CMP_OP:
-        strcpy(str_type,FI_CMP_FAULTY_OP);
-     	break; 
-     case FI_XOR_OP:
-     	strcpy(str_type,FI_XOR_FAULTY_OP);
-	break;
-     case FI_SARL_OP:
-	strcpy(str_type,FI_SARL_FAULTY_OP);
-	break;
-     case FI_IDIVL_OP:
-	strcpy(str_type,FI_IDIVL_FAULTY_OP);
-	break;
-     case FI_IADDL_OP:
-	strcpy(str_type,FI_IADDL_FAULTY_OP);
-	break;
-     case FI_ISUBL_OP:
-	strcpy(str_type,FI_ISUBL_FAULTY_OP);
-	break;
-     case FI_SHRL_OP:
-	strcpy(str_type,FI_SHRL_FAULTY_OP);
-	break;
-     case FI_ANDL_OP:
-	strcpy(str_type,FI_ANDL_FAULTY_OP);
-	break;
-     case FI_ORL_OP:
-	strcpy(str_type,FI_ORL_FAULTY_OP);
-	break;
-     case FI_XORL_OP:
-	strcpy(str_type,FI_XORL_FAULTY_OP);
-	break;
-     case FI_MOVL_OP:
-	strcpy(str_type,FI_MOVL_FAULTY_OP);
-	break;
-     case FI_TESTL_OP:
-	strcpy(str_type,FI_TESTL_FAULTY_OP);
-	break;
-     case FI_NOTL_OP:
-	strcpy(str_type,FI_NOTL_FAULTY_OP);
-	break;
-     default:
-        strcpy(str_type, "Unknown");
-     	break;	
-   }  
-      SEFI_writelog(cpu_single_env->func_name, "FaultyOp:%s, EIP: 0x%08X, Flip Mask: 0x%016"PRIx64"%016"PRIx64", BeforeInjection:%.18Lf (0x%016"PRIx64"%016"PRIx64"), AfterInjection:%.18Lf(0x%016"PRIx64"%016"PRIx64"),  DIC:%lu\n", 
-       str_type,
-       cpu_single_env->eip, 
-       (uint64_t)(flip>>64),(uint64_t)flip,
-       (long double)reg, 
-        (uint64_t)(*((unsigned __int128 *)(&reg))>>64),(uint64_t)*((unsigned __int128 *)(&reg)), 
-       *((long double *)(&tmp)), 
-       (uint64_t)(tmp>>64),(uint64_t)tmp, 
-       dic_count
-       );
-#if 0
-   SEFI_writelog(cpu_single_env->func_name, "FaultyOp:%s,eip:0x%08lX, Original:%lf, BitflipMask:0x%lX, AfterInjection:%lf DynamicInstruction:%lu\n",
-                                  str_type,
-				  cpu_single_env->eip,
-				  (double)reg,
-				  flip,
-				  *((double *)(&tmp)),
-				  dic_count
-				  );
-#endif
-   // Resigned the flipped value to register	  
-   *ST0_reg = *((long double*)(&tmp));
-   //return *((double *)(&tmp));
-   //return ret_val;
-
-}
-
-// fault injection func
-// For memory/cache fault only
-double SEFI_helper_bit_flip_double_in_memory(double val){
-   long int j;
-   unsigned long int flip, tmp;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   // Get the pointer of ST0 to a unsigned long int para
-   tmp = *((unsigned long int *)(&val));
-   
-   // for random seed
-   base = cpu_single_env->start_bit; 
-   denom = (cpu_single_env->end_bit)+1 - cpu_single_env->start_bit;
-  
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < cpu_single_env->num_bit; iter++){   
-     j = rand()%denom+base;
-     flip = flip | (unsigned long int)((unsigned long int)1<<j);
-   }
-   tmp = tmp ^flip;
-   //printf("Eip: 0x%08X, BitFlipMask: %08lX, AfterInjection:%lf, BeforeInjection:%lf DIC:%lu\n", env->eip, flip, *((double *)(&tmp)), (double)ST0_reg, dic_count);
-   return *((double *)(&tmp));
-
-}
-
-
-
-
-void SEFI_helper_profiling_count(uint32_t type, uint32_t *reg_A, uint32_t *reg_B){
-  if(cpu_single_env->is_inject_allowed && cpu_single_env->is_inject_triggered && CHECK_MEMORY_RANGE){
-    switch(type){
-      case FI_ADD_OP:
-        cpu_single_env->fadd_count++;
-     	break;
-      case FI_MUL_OP:
-        cpu_single_env->fmul_count++;
-     	break;
-      case FI_CMP_OP:
-        cpu_single_env->cmp_count++;
-     	break; 
-      case FI_XOR_OP:
-        cpu_single_env->xor_count++;
-	break;
-      case FI_SARL_OP:
-        cpu_single_env->sarl_count++;
-	break;
-      case FI_IDIVL_OP:
-        cpu_single_env->idivl_count++;
-	break;
-      case FI_IMUL_OP:
-        cpu_single_env->imul_count++;
-	break;
-      case FI_IADDL_OP:
-	cpu_single_env->iaddl_count++;
-	break;	 
-      case FI_ISUBL_OP:
-	cpu_single_env->isubl_count++;
-	break;	
-      case FI_SHRL_OP:
-	cpu_single_env->shrl_count++;
-	break;	
-      case FI_ANDL_OP:
-	cpu_single_env->andl_count++;
-	break;	
-      case FI_ORL_OP:
-	cpu_single_env->orl_count++;
-	break;	
-      case FI_XORL_OP:
-	cpu_single_env->xorl_count++;
-	break;	
-      case FI_MOVL_OP:
-	cpu_single_env->movl_count++;
-	break;	
-      case FI_TESTL_OP:
-	cpu_single_env->testl_count++;
-	break;	
-      case FI_NOTL_OP:
-	cpu_single_env->notl_count++;
-	break;	
-      case FI_LD_OP:
-	cpu_single_env->ld_count++;
-	break;	
-
-
-
-      default: // need to de updated soon
-     	break;	
-    }
-    /*
-    if(reg_A!=NULL && reg_B!=NULL){
-      printf("regA:%lu regB:%lu\n", *reg_A, *reg_B);
-    }
-    */
-    //printf("fadd:%u, fmul:%u, imul:%u\n", cpu_single_env->fadd_count, cpu_single_env->fmul_count, cpu_single_env->imul_count);
-  } 
-}
-int SEFI_helper_write_type_2_count(uint32_t type, uint64_t curr){
-  switch(type){
-      case FI_ADD_OP:
-          cpu_single_env->fadd_count = curr;
-     	break;
-      case FI_MUL_OP:
-          cpu_single_env->fmul_count = curr;
-     	break;
-      case FI_CMP_OP:
-          cpu_single_env->cmp_count = curr;
-     	break; 
-      case FI_XOR_OP:
-          cpu_single_env->xor_count = curr;
-	break;
-      case FI_SARL_OP:
-         cpu_single_env->sarl_count = curr;
-	break;
-      case FI_IDIVL_OP:
-         cpu_single_env->idivl_count = curr;
-	break;
-      case FI_IMUL_OP:
-         cpu_single_env->imul_count = curr;
-	break; 
-      case FI_IADDL_OP:
-         cpu_single_env->iaddl_count = curr;
-	break;
-      case FI_ISUBL_OP:
-         cpu_single_env->isubl_count = curr;
-	break;
-      case FI_SHRL_OP:
-         cpu_single_env->shrl_count = curr;
-	break;
-      case FI_ANDL_OP:
-         cpu_single_env->andl_count = curr;
-	break;
-      case FI_ORL_OP:
-         cpu_single_env->orl_count = curr;
-	break;
-      case FI_XORL_OP:
-         cpu_single_env->xorl_count = curr;
-	break;
-      case FI_MOVL_OP:
-         cpu_single_env->movl_count = curr;
-	break;
-      case FI_TESTL_OP:
-	cpu_single_env->testl_count = curr;
-	break;
-      case FI_NOTL_OP:
-	cpu_single_env->notl_count = curr;
-	break;
-      case FI_LD_OP:
-	cpu_single_env->ld_count = curr;
-	break;
-
-
-      default: // need to de updated soon
-     	break;	
-    }
-  return 1;
-
-}
-
-int SEFI_helper_read_type_2_count(uint32_t type, uint64_t *p_curr, uint64_t *p_lower){
-  switch(type){
-      case FI_ADD_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->fadd_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_fadd;
-     	break;
-      case FI_MUL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->fmul_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_fmul;
-     	break;
-      case FI_CMP_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->cmp_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_cmp;
-     	break; 
-      case FI_XOR_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->xor_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_xor;
-	break;
-      case FI_SARL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->sarl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_sarl;
-	break;
-      case FI_IDIVL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->idivl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_idivl;
-	break;
-      case FI_IMUL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->imul_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_imul;
-	break;
-      case FI_IADDL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->iaddl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_iaddl;
-	break;
-      case FI_ISUBL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->isubl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_isubl;
-	break;
-      case FI_SHRL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->shrl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_shrl;
-	break;
-      case FI_ANDL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->andl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_andl;
-	break;
-      case FI_ORL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->orl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_orl;
-	break;
-      case FI_XORL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->xorl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_xorl;
-	break;
-      case FI_MOVL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->movl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_movl;
-	break;
-      case FI_TESTL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->testl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_testl;
-	break;
-      case FI_NOTL_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->notl_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_notl;
-	break;
-      case FI_LD_OP:
-	if(p_curr != NULL)
-          *p_curr = cpu_single_env->ld_count;
-	if(p_lower != NULL)
-	  *p_lower = cpu_single_env->start_of_ld;
-	break;
-
-
-      default: // need to de updated soon
-     	break;	
-    }
-  return 1;
-
-}
-
-int SEFI_helper_pass_probability(){
-  double j, probability;
-  probability=cpu_single_env->fault_probability;
-  if(probability == 100)
-    return 1;
-  j=drand48()*100;
-  return (j>=(100-probability)) ? 1:0;
-}
-
-
-int SEFI_helper_hit(uint32_t type){ 
-  int i;
-  uint64_t current, lower;
-  
-  SEFI_helper_read_type_2_count(type, &current, &lower);
-  if(cpu_single_env->fault_probability !=0){
-    cpu_single_env->counter = 2; // any number larger than 1
-    return SEFI_helper_pass_probability();
-  }
-  //printf(" %lld <-> %lld ", current, lower);
-  for(i=0; i< cpu_single_env->counter; i++){
-    if(current == cpu_single_env->p_chosen_dic[i]+lower){
-      /* Debug lines
-      for(j=0; j<cpu_single_env->counter; j++){
-      	printf(" %ld ", cpu_single_env->p_chosen_dic[j]);
-      }
-      printf( "\n");
-      */
-      cpu_single_env->p_chosen_dic[i] = cpu_single_env->p_chosen_dic[cpu_single_env->counter-1];
-      return 1;
-    }
-
-  }
-  return 0;
-}
-
-// Check injector condition
-int SEFI_helper_check_condition(uint32_t type){
-   if(cpu_single_env->is_inject_allowed 
-     && cpu_single_env->is_inject_triggered 
-     && (cpu_single_env->inject_type == type)      // flip type -- No longer need to check the type - by guanxyz
-     && CHECK_MEMORY_RANGE
-     ){
-   	int res = SEFI_helper_hit(type);
-	if(res)
-	  return 1;
-	else
-     	  return 0;
-   }
-   else
-	return 0;
-}
-
-
-#if 1
-// The function (uint 32)
-int SEFI_helper_inject_faults_uint32_reg(uint32_t *reg_A, uint32_t *reg_B, uint32_t type){
-  
-  // Profile
-  SEFI_helper_profiling_count(type, reg_A, reg_B);
-  if (SEFI_helper_check_condition(type) && (cpu_single_env->counter>0)){
-       // reg_A and reg_B could not be NULL at the same time
-       if(reg_A==NULL && reg_B != NULL)
-	 *reg_B = SEFI_helper_bit_flip_uint32(*reg_B, type);
-       else if(reg_B == NULL && reg_A !=NULL)
-	 *reg_A = SEFI_helper_bit_flip_uint32(*reg_A, type);
-       else{
-	 if(SEFI_helper_probability(5)){
-	   *reg_A = SEFI_helper_bit_flip_uint32(*reg_A, type);
-	 }else{
-	   *reg_B = SEFI_helper_bit_flip_uint32(*reg_B, type);
-	 }
-
-       }
-       cpu_single_env->counter--;
-       if(cpu_single_env->counter <= 0){
-       	 SEFI_helper_turn_off_injector(type);
-       }
-  }
-  return 1;
-   
-}
-
-int SEFI_helper_inject_faults_double64_reg(long double *reg_A, long double *reg_B, uint32_t type){
-  
-  // Profile
-  SEFI_helper_profiling_count(type, NULL, NULL);
-  if (SEFI_helper_check_condition(type)){
-     if(cpu_single_env->counter>0){
-       // reg_A and reg_B could not be NULL at the same time
-       if(reg_A==NULL && reg_B != NULL)
-	 SEFI_helper_bit_flip_double64(reg_B, type);
-       else if(reg_B == NULL && reg_A !=NULL)
-	 SEFI_helper_bit_flip_double64(reg_A, type);
-       else{
-	 if(SEFI_helper_probability(5)){
-           printf("Before injection A: %Lf\n", *reg_A);
-	   //*reg_A = SEFI_helper_bit_flip_double64(*reg_A, type);
-	   SEFI_helper_bit_flip_double64(reg_A, type);
-	 }else{
-           printf("Before injection B: %Lf\n", *reg_B);
-	   SEFI_helper_bit_flip_double64(reg_B, type);
-	 }
-
-       }
-       /*
-       if(reg_B!=NULL)
-         printf("After injection B :%Lf \n", *reg_B); 
-       if(reg_A!=NULL)
-         printf("After injection A :%Lf \n", *reg_A);
-       */
-       cpu_single_env->counter--;
-       if(cpu_single_env->counter <= 0){
-     	 SEFI_helper_turn_off_injector(type);
-       }
-
-     }
-  }
-  return 1;
-   
-}
-
-
-
-
-
-#endif
-
-
-
 
-uint32_t SEFI_helper_bit_flip_ulong_ex(uint32_t T0_reg, uint32_t T_reg, int op_type, uint32_t dic_count){
-   uint32_t j;
-   uint32_t flip, tmp;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   
-      // Get the pointer of ST0 to a unsigned long int para
-   tmp = T0_reg;
-   printf("You hit it!\n");
-   printf("unmasked Register:%x\n",tmp);
-   
-   // for random seed
-   base = cpu_single_env->start_bit; 
-   denom = (cpu_single_env->end_bit)+1 - cpu_single_env->start_bit;
-   
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < cpu_single_env->num_bit; iter++){   
-     j = rand()%denom+base;
-     // bit flip
-     // For multiple flips 
-     flip = flip | (uint32_t)((uint32_t)1<<j);
-   }
-
-   /*
- 	* Mask the value with flipmask
-   */
-
-   tmp = tmp ^flip;
-
-   printf("EIP:0x%08X, Flip Mask: %08x, Masked Register:%08x DIC : %d \n",cpu_single_env->eip, flip, tmp, dic_count);
-   
-   switch(op_type){
-     case FI_ADD_OP:
-        strcpy(str_type,FI_ADD_FAULTY_OP);
-     	break;
-     case FI_MUL_OP:
-        strcpy(str_type,FI_MUL_FAULTY_OP);
-     	break;
-     case FI_CMP_OP:
-        strcpy(str_type,FI_CMP_FAULTY_OP);
-     	break; 
-     case FI_XOR_OP:
-     	strcpy(str_type,FI_XOR_FAULTY_OP);
-	break;
-     case FI_SARL_OP:
-	strcpy(str_type,FI_SARL_FAULTY_OP);
-	break;
-     default:
-        strcpy(str_type, "Unknown");
-     	break;	
-   }   
-   SEFI_writelog(cpu_single_env->func_name, "FaultyOp:%s,eip:0x%08lX, Original:%lu, BitflipMask:%08lX, AfterInjection:%lu, DynamicInstruction:%d, other:%lu\n",
-                                  str_type,
-				  cpu_single_env->eip,
-				  T0_reg,
-				  flip,
-				  tmp,
-				  dic_count,
-				  T_reg
-   );
-   
-   // Resigned the flipped value to register	  
-   return tmp;
-
-}
-
-// pwu: mem fault begin
-int already_corrupted(uint32_t addr) 
-{
-	uint32_t *caddrs = cpu_single_env->corrupted_addrs;
-	int nc = cpu_single_env->num_corruptions;
-	int i;
-	for (i=0; i<nc; i++) 
-		if( caddrs[i] == addr ) return i;
-	return -1;
-}
-void clear_corruption(uint32_t addr) 
-{
-	uint32_t *caddrs = cpu_single_env->corrupted_addrs;
-	double *cvals = cpu_single_env->corrupted_values;
-	int nc = cpu_single_env->num_corruptions;
-	int i;
-	for (i=0; i<nc; i++) {
-		if( caddrs[i] == addr ) {
-			cpu_single_env->num_corruptions--;
-			break;
-		}
-	}	
-	for (i;i<nc-1; i++) {
-		caddrs[i] = caddrs[i+1];
-		cvals[i] = cvals[i+1];
-	}
-			
-}	
-void SEFI_helper_inject_faults_double_mem(uint32_t addr, double *val, int instr_type)
-{
-	int i, nc;
-	if (instr_type == SEFI_TYPE_LD) {
-		SEFI_helper_profiling_count(SEFI_TYPE_LD, NULL, NULL);
-		if ((i=already_corrupted(addr)) >= 0) {
-			*val = cpu_single_env->corrupted_values[i];
-		}
-		if (SEFI_helper_check_condition(instr_type) &&
-			cpu_single_env->counter > 0) {
-			double newval = SEFI_helper_bit_flip_double_in_memory(*val);
-							
-			if (i >= 0) {
-				term_printf("Memfault, eip:0x%08lX, Original:%g(%16lX),AfterInjection:%g(%16lX),injecting to already corrupted addr.\n",
-							cpu_single_env->eip, *val, *(unsigned long*)val, newval, *(unsigned long*)&newval );
-				
-				SEFI_writelog(	cpu_single_env->func_name, 
-							"Memfault, eip:0x%08lX, Original:%g(%16lX), "
-							"AfterInjection:%g(%16lX), "
-							"injecting to already corrupted addr.\n",
-							cpu_single_env->eip,*val, *(unsigned long*)val, newval, *(unsigned long*)&newval );
-				cpu_single_env->corrupted_values[i] = *val;
-				
-			} else {				
-			  	term_printf("Memfault, eip:0x%08lX, Original:%g(%16lX), AfterInjection:%g(%16lX), \n",
-							cpu_single_env->eip, *val, *(unsigned long*)val, newval, *(unsigned long*)&newval);
-
-				SEFI_writelog(	cpu_single_env->func_name, 
-							"Memfault, eip:0x%08lX, Original:%g(%16lX), "
-							"AfterInjection:%g(%16lX), "
-							"\n",
-							cpu_single_env->eip, *val, *(unsigned long*)val, newval, *(unsigned long*)&newval);
-				nc = ++cpu_single_env->num_corruptions;
-				cpu_single_env->corrupted_addrs[nc] = addr;
-				cpu_single_env->corrupted_values[nc] = *val;
-			}
-			*val *= newval; // TODO: randomly corrupt
-			cpu_single_env->counter--;
-			if( cpu_single_env->counter <= 0 ) {
-				SEFI_helper_turn_off_injector( instr_type );
-			}
-		}
-			
-			
-		
-	} else if (instr_type == SEFI_TYPE_ST) {
-		clear_corruption(addr);
-	}
-}
-// pwu: mem fault end.
-/*
-#include "TEMU_main.h"
-void print_something(void){
-     if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->cmp_count++;
-  	SEFI_writelog(env->func_name, "ProfileCMP:%d, eip:0x%08lX\n", env->cmp_count, env->eip);
-   }
-   
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_CMP_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-     &&	(env->cmp_count == env->chosen_dic)
-     )		// flip start
-     {
-	if(env->counter>0){ // counter is to count the injection times
-	  // Fault is injected into T1
-	  T1 = SEFI_helper_bit_flip_ulong(T1, SEFI_CMP_OP);
-
-	  CC_SRC = T1;
-	  CC_DST = T0 - T1;
-          opprintf(T0, T1);
-
-    	  //CC_DST = SEFI_helper_bit_flip_ulong(CC_DST, SEFI_CMP_OP);
-	  //CC_DST = T1 - T0;
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->cmp_count = 0; 
-	 
-	}else{
-	  CC_SRC = T1;
-	  CC_DST = T0 - T1;
-
-	}
-    }
-    else{
-      CC_SRC = T1;
-      CC_DST = T0 - T1;
-    } 
-  term_printf("I am here !\n");
-}
-
-*/
-#endif
 #endif //#if TAINT_ENABLED
Only in PFSEFI_for_patch: taintcheck.c.cp
Only in PFSEFI_for_patch: taintcheck.c.new
diff --exclude=tracecap -ur PFSEFI_for_patch/taintcheck.h /Users/QGuan/Downloads/temu-1.0/taintcheck.h
--- PFSEFI_for_patch/taintcheck.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/taintcheck.h	2009-11-23 12:38:10.000000000 -0700
@@ -235,12 +235,4 @@
 
 void do_info_taintmem(void);
 
-void print_something(void);
-void print_something_t(int val);
-uint32_t SEFI_helper_bit_flip_ulong_ex(uint32_t T0_reg, uint32_t T_reg, int op_type, uint32_t dic_count);
-int SEFI_helper_probability(int rate);
-int SEFI_helper_inject_faults_uint32_reg(uint32_t *reg_A, uint32_t *reg_B, uint32_t type);
-int SEFI_helper_inject_faults_double64_reg(long double *reg_A, long double *reg_B, uint32_t type);
-void SEFI_helper_inject_faults_double_mem(uint32_t addr, double *val, int instr_type);
-
 #endif
Only in PFSEFI_for_patch/target-i386: a.out
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/cpu.h /Users/QGuan/Downloads/temu-1.0/target-i386/cpu.h
--- PFSEFI_for_patch/target-i386/cpu.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/cpu.h	2009-11-23 12:38:09.000000000 -0700
@@ -293,7 +293,6 @@
 #define CPUID_PBE (1 << 31)
 
 #define CPUID_EXT_SSE3     (1 << 0)
-#define CPUID_EXT_DTES64   (1 << 2)	
 #define CPUID_EXT_MONITOR  (1 << 3)
 #define CPUID_EXT_DSCPL    (1 << 4)
 #define CPUID_EXT_VMX      (1 << 5)
@@ -304,7 +303,6 @@
 #define CPUID_EXT_CID      (1 << 10)
 #define CPUID_EXT_CX16     (1 << 13)
 #define CPUID_EXT_XTPR     (1 << 14)
-#define CPUID_EXT_PDCM     (1 << 15)
 #define CPUID_EXT_DCA      (1 << 17)
 #define CPUID_EXT_POPCNT   (1 << 22)
 
@@ -603,66 +601,6 @@
     /* in order to simplify APIC support, we leave this pointer to the
        user */
     struct APICState *apic_state;
-    
-#if 1    
-    /* in order to control the fault injection  */
-    /* -- Guan                                  */
-    target_ulong inject_start_addr;
-    target_ulong inject_end_addr;
-    uint8_t is_inject_allowed;
-    uint8_t is_inject_triggered;
-    int64_t counter;	// number of faults per run
-    uint64_t p_chosen_dic[1000];  // dynamic array for defining which numbers are chosen (max :1000)
-    uint32_t inject_type;
-    char func_name[128];
-    // Load from SEFI_conf.ini
-    uint16_t start_bit;
-    uint16_t end_bit;
-    uint16_t num_bit;
-    double fault_probability;
-    uint64_t start_of_fadd;
-    uint64_t start_of_fmul;
-    uint64_t start_of_cmp;
-    uint64_t start_of_xor;
-    uint64_t start_of_sarl;
-    uint64_t start_of_idivl;
-    uint64_t start_of_imul;
-    uint64_t start_of_iaddl;
-    uint64_t start_of_isubl;
-    uint64_t start_of_shrl;
-    uint64_t start_of_andl;
-    uint64_t start_of_orl;
-    uint64_t start_of_xorl;
-    uint64_t start_of_movl;
-    uint64_t start_of_testl;
-    uint64_t start_of_notl;
-    uint64_t start_of_ld;
-    uint64_t chosen_dic;
-    // Profle the program
-    uint16_t profile_type;
-    uint64_t fadd_count;
-    uint64_t fmul_count;
-    uint64_t cmp_count;
-    uint64_t xor_count;
-    uint64_t sarl_count;
-    uint64_t idivl_count;
-    uint64_t imul_count;	// integer multiply
-    uint64_t iaddl_count;	// integer
-    uint64_t isubl_count;	// integer 
-    uint64_t shrl_count;	// 
-    uint64_t andl_count;	//  
-    uint64_t orl_count;		// 
-    uint64_t xorl_count;	//  
-    uint64_t movl_count;	// 
-    uint64_t testl_count;	// 
-    uint64_t notl_count;	// 
-    uint64_t ld_count;	// 
-    // Process states under profile
-    // pwu: memory faults
-	uint32_t corrupted_addrs[1000];
-	double corrupted_values[1000];
-	int num_corruptions; 
-#endif
 } CPUX86State;
 
 CPUX86State *cpu_x86_init(const char *cpu_model);
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/helper.c /Users/QGuan/Downloads/temu-1.0/target-i386/helper.c
--- PFSEFI_for_patch/target-i386/helper.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/helper.c	2009-11-23 12:38:09.000000000 -0700
@@ -1652,61 +1652,27 @@
 void helper_idivl_EAX_T0(void)
 {
     int den, r;
-    int64_t num, q; 
-    
-   // SEFI_helper_inject_faults_uint32_reg(&T0, &EAX, SEFI_TYPE_IDIVL);
+    int64_t num, q;
+
     num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
     den = T0;
-	
-    /*
-    if(env->is_inject_allowed  
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->idivl_count++;
-    }
-    
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_IDIVL_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-    // &&(env->idivl_count == env->chosen_dic)
-     && (SEFI_helper_hit_dic(env->idivl_count, env->start_of_idivl))
-    )
-    {	 
-      {// Fault injections
-       if(env->counter>0){ // counter is to count the injection times
-
-          if( SEFI_helper_probability(5))
-	     num = SEFI_helper_bit_flip_ulong_ex(num, den, 6, env->idivl_count);  // SEFI_IDIVL_OP = 6
-	  else
-	     den = SEFI_helper_bit_flip_ulong_ex(den, num, 6, env->idivl_count);
-	  
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->idivl_count = 0; 
-      	}
-      }
-     }
-     */
-      if (den == 0) {
+    if (den == 0) {
         raise_exception(EXCP00_DIVZ);
-      }
+    }
 #ifdef BUGGY_GCC_DIV64
-      r = idiv32(&q, num, den);
+    r = idiv32(&q, num, den);
 #else
-      q = (num / den);
-      r = (num % den);
+    q = (num / den);
+    r = (num % den);
 #endif
- 
-
-    // Post-process
     if (q != (int32_t)q)
         raise_exception(EXCP00_DIVZ);
     EAX = (uint32_t)q;
     EDX = (uint32_t)r;
-//    printf("EAX: %d EDX:%d EBX:%d\n", q, r, EBX);
+#if TAINT_ENABLED
+    taintcheck_fn3regs(R_EAX, R_EDX, R_T0, R_EAX, 4);
+    taintcheck_reg2reg(R_EAX, R_EDX, 4);
+#endif
 }
 
 void helper_cmpxchg8b(void)
@@ -3701,15 +3667,8 @@
         nb_xmm_regs = 8 << data64;
         addr = ptr + 0xa0;
         for(i = 0; i < nb_xmm_regs; i++) {
-#if defined(__i386__) && __GNUC__ >= 4
-            env->xmm_regs[i].XMM_L(0) = ldl(addr);
-            env->xmm_regs[i].XMM_L(1) = ldl(addr + 4);
-            env->xmm_regs[i].XMM_L(2) = ldl(addr + 8);
-            env->xmm_regs[i].XMM_L(3) = ldl(addr + 12);
-#else
             env->xmm_regs[i].XMM_Q(0) = ldq(addr);
             env->xmm_regs[i].XMM_Q(1) = ldq(addr + 8);
-#endif
             addr += 16;
         }
     }
Only in PFSEFI_for_patch/target-i386: helper.c.orig
Only in PFSEFI_for_patch/target-i386: helper.c.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/helper2.c /Users/QGuan/Downloads/temu-1.0/target-i386/helper2.c
--- PFSEFI_for_patch/target-i386/helper2.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/helper2.c	2009-11-23 12:38:09.000000000 -0700
@@ -202,24 +202,6 @@
         .features = 0x0383F9FF,
         .xlevel = 0,
     },
-    {
-        .name = "core2duo",
-        .level = 10,
-        .family = 6,
-        .model = 15,
-        .stepping = 11,
-        .features = PPRO_FEATURES |
-            CPUID_MTRR | CPUID_CLFLUSH | CPUID_MCA |
-            CPUID_PSE36 | CPUID_VME | CPUID_DTS | CPUID_ACPI | CPUID_SS |
-            CPUID_HT | CPUID_TM | CPUID_PBE,
-        .ext_features = CPUID_EXT_SSE3 | CPUID_EXT_MONITOR | CPUID_EXT_SSSE3 |
-            CPUID_EXT_DTES64 | CPUID_EXT_DSCPL | CPUID_EXT_VMX | CPUID_EXT_EST |
-            CPUID_EXT_TM2 | CPUID_EXT_CX16 | CPUID_EXT_XTPR | CPUID_EXT_PDCM,
-        .ext2_features = CPUID_EXT2_LM | CPUID_EXT2_SYSCALL | CPUID_EXT2_NX,
-        .ext3_features = CPUID_EXT3_LAHF_LM,
-        .xlevel = 0x80000008,
-    },
-
 };
 
 static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)
@@ -321,9 +303,8 @@
 {
     x86_def_t def1, *def = &def1;
 
-    if (cpu_x86_find_by_name(def, cpu_model) < 0){
+    if (cpu_x86_find_by_name(def, cpu_model) < 0)
         return -1;
-    }
     if (def->vendor1) {
         env->cpuid_vendor1 = def->vendor1;
         env->cpuid_vendor2 = def->vendor2;
Only in PFSEFI_for_patch/target-i386: inject_type
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/op.c /Users/QGuan/Downloads/temu-1.0/target-i386/op.c
--- PFSEFI_for_patch/target-i386/op.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/op.c	2009-11-23 12:38:09.000000000 -0700
@@ -22,27 +22,9 @@
 #include "exec.h"
 #include "TEMU_main.h"
 
-// by Guan
-#include "time.h"
-#include "stdlib.h"
-#define SEFI_MUL_OP 1
-#define SEFI_ADD_OP 2
-#define SEFI_CMP_OP 3
-#define SEFI_XOR_OP 4
-#define SEFI_SARL_OP 5
-#define SEFI_IDIVL_OP 6
-#define SEFI_IMUL_OP  7
-#define SEFI_MUL_FAULTY_OP "MUL_OP"
-#define SEFI_ADD_FAULTY_OP "ADD_OP"
-#define SEFI_CMP_FAULTY_OP "CMP_OP"
-#define SEFI_XOR_FAULTY_OP "XOR_OP"
-#define SEFI_SARL_FAULTY_OP "SARL_OP"
-#define SEFI_IDIVL_FAULTY_OP "IDIVL_OP"
-#define SEFI_IMUL_FAULTY_OP "IMUL_OP"
-
 /* n must be a constant to be efficient */
 static inline target_long lshift(target_long x, int n)
-{    
+{
     if (n >= 0)
         return x << n;
     else
@@ -247,8 +229,6 @@
 
 #endif
 
-int SEFI_helper_hit_dic(uint64_t current_count, uint64_t lower_bound);
-void SEFI_helper_free_candidates();
 /* operations with flags */
 
 /* update flags with T0 and T1 (add/sub case) */
@@ -281,169 +261,6 @@
 #endif	
 }
 
-/* Faulty opercodes on cmp */
-/* By guanxyz */
-void opprintf();
-
-
-
-// fault injection func
-// here ulobg == uint32
-target_ulong SEFI_helper_bit_flip_ulong(target_ulong T0_reg, int op_type, uint64_t dic_count){
-   target_ulong j;
-   target_ulong flip, tmp;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   // Get the pointer of ST0 to a unsigned long int para
-   tmp = T0_reg;
-   //printf("unmasked Register:%x\n",tmp);
-   
-   // for random seed
-   base = env->start_bit; 
-   denom = (env->end_bit)+1 - env->start_bit;
-   
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < env->num_bit; iter++){   
-     j = rand()%denom+base;
-     // bit flip
-     // For multiple flips 
-     flip = flip | (target_ulong)((target_ulong)1<<j);
-   }
-   /*
-   j = rand()%12+52;
-   // bit flip
-   flip= (unsigned long int)((unsigned long int)1<<j);
-   */
-   tmp = tmp ^flip;
-   printf("EIP:0x%08X, Flip Mask: %08x (%d), Masked Register:%08x DIC : %lu \n",env->eip, flip, sizeof(target_ulong), tmp, dic_count);
-   
-   switch(op_type){
-     case SEFI_ADD_OP:
-        strcpy(str_type,SEFI_ADD_FAULTY_OP);
-     	break;
-     case SEFI_MUL_OP:
-        strcpy(str_type,SEFI_MUL_FAULTY_OP);
-     	break;
-     case SEFI_CMP_OP:
-        strcpy(str_type,SEFI_CMP_FAULTY_OP);
-     	break; 
-     case SEFI_XOR_OP:
-     	strcpy(str_type,SEFI_XOR_FAULTY_OP);
-	break;
-     case SEFI_SARL_OP:
-	strcpy(str_type,SEFI_SARL_FAULTY_OP);
-	break;
-     case SEFI_IDIVL_OP:
-	strcpy(str_type,SEFI_IDIVL_FAULTY_OP);
-	break;
-     case SEFI_IMUL_OP:
-	strcpy(str_type,SEFI_IMUL_FAULTY_OP);
-	break;
-     default:
-        strcpy(str_type, "Unknown");
-     	break;	
-   }   
-   SEFI_writelog(env->func_name, "FaultyOp:%s,eip:0x%08lX, Original:%d(size:%d), BitflipMask:%08lX(size:%d), AfterInjection:%d(size:%d), DynamicInstruction:%lu\n",
-                                  str_type,
-				  env->eip,
-				  (int32_t)T0_reg,sizeof(T0_reg),
-				  flip,sizeof(flip),
-				  (int32_t)tmp,sizeof(tmp),
-				  dic_count
-   );
-   
-   // Resigned the flipped value to register	  
-   return tmp;
-
-}
-int SEFI_helper_check_mem();
-void opprintcount(){
-  //printf("--> Num of faults to inject :%d Current Count: %d Start index: %d\n", env->counter, env->fadd_count, env->start_of_fadd);
-}
-void opprinteip(){
-}
-void SEFI_helper_show_CP(void){
-}
-void SEFI_helper_save_profiling(){
-  //SEFI_writelog(env->func_name, "ProfileCMP:%d, profileSARL:%d, eip:0x%08lX\n", env->cmp_count, env->sarl_count, env->eip);
-}
-
-#if 0
-void OPPROTO op_cmpl_T0_T1_cc(void)
-{     
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-   //	opprintcount();
-	env->cmp_count++;
-   //	SEFI_helper_save_profiling();
-   }
-   
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_CMP_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-     && (SEFI_helper_hit_dic(env->cmp_count, env->start_of_cmp))
-     )		// flip start
-     {
-	if(env->counter>0){ // counter is to count the injection times
- 	  /*
- 	    * The Register is shifted 16 bits to the right
- 	    *
- 	  */
-          T0  = T0<<16;
-          T1  = T1<<16;
-
-
-          if( SEFI_helper_probability(5)) 
- 	     // The first register will be contanminated
-	     T0 = SEFI_helper_bit_flip_ulong_ex(T0, T1, SEFI_CMP_OP, env->cmp_count);
-	  else
-	     T1 = SEFI_helper_bit_flip_ulong_ex(T1, T0, SEFI_CMP_OP, env->cmp_count);
-	  
-	  CC_SRC = T1;
-	  CC_DST = T0 - T1;
-          opprintf(T0, T1);
-
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->cmp_count = 0; 
-	 
-	}else{
-	  CC_SRC = T1;
-	  CC_DST = T0 - T1;
-
-/*	  //env->counter--;
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->cmp_count = 0; 
-*/
-	}
-    }
-    else{
-      CC_SRC = T1;
-      CC_DST = T0 - T1;
-    } 
-#if 0 /* this function has been moved to the beginning */   
-    // Count OPs under Profile mode
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     &&(env->profile_type & SEFI_PROFILE_CMP)
-     && SEFI_helper_check_mem())
-	env->cmp_count++;
-#endif
-#if TAINT_FLAGS
-	taintcheck_reg2reg(R_T1, R_CC_SRC, 4);
-	taintcheck_fn2regs(R_T0, R_T1, R_CC_DST, 4);
-#endif	
-}
-#endif
-
-#if 1
 void OPPROTO op_cmpl_T0_T1_cc(void)
 {
     CC_SRC = T1;
@@ -454,8 +271,6 @@
 #endif	
 }
 
-#endif
-
 void OPPROTO op_update_inc_cc(void)
 {
     CC_SRC = cc_table[CC_OP].compute_c();
@@ -478,7 +293,6 @@
 
 void OPPROTO op_addl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_IADDL);  // -- Injection
     T0 += T1;
 #if TAINT_ENABLED 
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
@@ -487,7 +301,6 @@
 
 void OPPROTO op_orl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_ORL);  // -- Injection
     T0 |= T1;
 #if TAINT_ENABLED 
 	taintcheck_logic_T0_T1();
@@ -496,7 +309,6 @@
 
 void OPPROTO op_andl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_ANDL);  // -- Injection
     T0 &= T1;
 #if TAINT_ENABLED
     taintcheck_logic_T0_T1();
@@ -505,63 +317,19 @@
 
 void OPPROTO op_subl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_ISUBL);  // -- Injection 
     T0 -= T1;
 #if TAINT_ENABLED
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
 #endif
 }
-#if 0
-// added by guanxyz   
-void OPPROTO op_xorl_T0_T1(void)
-{
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_XOR_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()		// flip start
-     && (SEFI_helper_hit_dic(env->xor_count, env->start_of_xor))
-     )
-     {
-        //opprintf();
-	if(env->counter>0){ // counter is to count the injection times
-	  // Fault is injected into T1
-
-          T0 ^= T1;
-
-    	  T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_XOR_OP, env->xor_count);
-	  env->counter--;
-	}else{
-          T0 ^= T1;
 
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-
-	} 
-    }
-    else{
-       T0 ^= T1;
-    }
-    // Count OPs under Profile mode
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && (env->profile_type & SEFI_PROFILE_XOR)
-     && SEFI_helper_check_mem()){
-	env->xor_count++;
-    }
-}
-#endif
-
-#if 1
 void OPPROTO op_xorl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_XORL);  // -- Injection
     T0 ^= T1;
 #if TAINT_ENABLED
 	taintcheck_logic_T0_T1();
 #endif
 }
-#endif
 
 void OPPROTO op_negl_T0(void)
 {
@@ -699,12 +467,6 @@
     EDX = (uint32_t)(res >> 32);
     CC_DST = res;
     CC_SRC = (res != (int32_t)res);
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-//	opprinteip();
-   }
-
 #if TAINT_ENABLED
     taintcheck_fn2regs(R_T0, R_EAX, R_EAX, 4);
     taintcheck_reg2reg(R_EAX, R_EDX, 4);
@@ -735,53 +497,10 @@
 void OPPROTO op_imull_T0_T1(void)
 {
     int64_t res;
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_IMULL);
-    res = (int64_t)((int32_t)T0) * (int64_t)((int32_t)T1);
-    T0 = res;
-    CC_DST = res;
-    CC_SRC = (res != (int32_t)res);
-
-}
-
-#if 0
-// Changed by guanxyz
-void OPPROTO op_imull_T0_T1(void)
-{
-    int64_t res;
-    // For profiling 
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->imul_count++;
-    }
-    // For injection
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_IMULL_BIT_FLIP     // flip type
-     && SEFI_helper_check_mem()
-     && (SEFI_helper_hit_dic(env->imul_count, env->start_of_fmul))
-     )
-     { 
-	if(env->counter>0){	
-	  if( SEFI_helper_probability(5)){	// With 50% probabality
-    	     T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_IMUL_OP, env->imul_count);
-	  }else{
-    	     T1 = SEFI_helper_bit_flip_ulong(T1, SEFI_IMUL_OP, env->imul_count);
- 	  }
-	  env->counter--;	
-	  if(env->counter==0){  
-	     env->is_inject_triggered = 0;
-	     env->is_inject_allowed = 0;
-	     env->imul_count = 0; 
-	  }
-	}
-    }
-    // back to original trace
     res = (int64_t)((int32_t)T0) * (int64_t)((int32_t)T1);
     T0 = res;
     CC_DST = res;
     CC_SRC = (res != (int32_t)res);
-
 #if TAINT_ENABLED
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
 #if TAINT_FLAGS
@@ -790,8 +509,6 @@
 #endif	
 #endif
 }
-#endif
-
 
 #ifdef TARGET_X86_64
 void OPPROTO op_mulq_EAX_T0(void)
@@ -926,7 +643,6 @@
 void OPPROTO op_movl_T0_imu(void)
 {
     T0 = (uint32_t)PARAM1;
-    SEFI_helper_inject_faults_uint32_reg(&T0, NULL, SEFI_TYPE_MOVL);
 #if TAINT_ENABLED
     taintcheck_reg_clean(R_T0);
 #endif
@@ -935,7 +651,6 @@
 void OPPROTO op_movl_T0_im(void)
 {
     T0 = (int32_t)PARAM1;
-    SEFI_helper_inject_faults_uint32_reg(&T0, NULL, SEFI_TYPE_MOVL);
 #if TAINT_ENABLED
     taintcheck_reg_clean(R_T0);
 #endif
@@ -967,7 +682,6 @@
 
 void OPPROTO op_movl_T0_T1(void)
 {
-    SEFI_helper_inject_faults_uint32_reg(NULL, &T1, SEFI_TYPE_MOVL);
     T0 = T1;
 #if TAINT_ENABLED
     taintcheck_reg2reg(R_T1, R_T0, 4);
@@ -2398,7 +2112,6 @@
 
 void OPPROTO op_flds_FT0_A0(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #ifdef USE_FP_CONVERT
     FP_CONVERT.i32 = ldl(A0);
     FT0 = FP_CONVERT.f;
@@ -2409,7 +2122,6 @@
 
 void OPPROTO op_fldl_FT0_A0(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #ifdef USE_FP_CONVERT
     FP_CONVERT.i64 = ldq(A0);
     FT0 = FP_CONVERT.d;
@@ -2503,18 +2215,12 @@
 void OPPROTO op_fldl_ST0_A0(void)
 {
     int new_fpstt;
-    double val;
     new_fpstt = (env->fpstt - 1) & 7;
-    //SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #ifdef USE_FP_CONVERT
     FP_CONVERT.i64 = ldq(A0);
-	val = FP_CONVERT.d;	
-	SEFI_helper_inject_faults_double_mem(A0, &val, SEFI_TYPE_LD);
-    env->fpregs[new_fpstt].d = val;
+    env->fpregs[new_fpstt].d = FP_CONVERT.d;
 #else
-	val = ldfq(A0);	
-	SEFI_helper_inject_faults_double_mem(A0, &val, SEFI_TYPE_LD);
-    env->fpregs[new_fpstt].d = val;
+    env->fpregs[new_fpstt].d = ldfq(A0);
 #endif
     env->fpstt = new_fpstt;
     env->fptags[new_fpstt] = 0; /* validate stack entry */
@@ -2631,7 +2337,6 @@
 
 void OPPROTO op_fstl_ST0_A0(void)
 {
-	SEFI_helper_inject_faults_double_mem(A0, NULL, SEFI_TYPE_ST);
     stfq(A0, (double)ST0);
     FORCE_RET();
 }
@@ -2858,627 +2563,15 @@
     FORCE_RET();
 }
 
-#if 1
 void OPPROTO op_fadd_ST0_FT0(void)
-{    
-    //double ST0_reg = (double)ST0;
-    //double FT0_reg = (double)FT0;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-    }
-
-    SEFI_helper_inject_faults_double64_reg(&ST0, &FT0, SEFI_TYPE_FADD); 
-    //ST0 = ST0_reg;
-    //FT0 = FT0_reg;
-    ST0 += FT0;
-}
-#endif
-/*
-void OPPROTO glue(glue(op_sar, SUFFIX), _T0_T1)(void)
-{
-    int count;
-    target_long src;
-
-    count = T1 _MASK;
-    src = (uint16_t)T0;
-    T0 = src >> count;
-    FORCE_RET();
-}*/
-void OPPROTO op_shrl_T0_T1(void)
-{
-    int count;
-    /*
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-    */
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_SHRL);
-    count = T1 & 0x1f;
-    T0 &= 0xffffffff;
-    T0 = T0 >> count;
-    FORCE_RET();
-}
-
-/*
-void OPPROTO op_sarl_T0_T1_cc(void)
-{
-    int count;
-    target_long src;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-    // Only when inject is allowed and triggered by monitor
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_SARL_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-     &&	(env->sarl_count == env->chosen_dic)
-     )		
-     // flip start
-     {	
-	if(env->counter>0){ // counter is to count the injection times
-	    count = T1 & 0x1f;
-	    if (count) {
-	        src = (uint32_t)T0;
-	        T0 = src >> count;
-	        src = src >> (count - 1);
-
-   		CC_SRC = src;
-	        CC_DST = T0;
-    		CC_OP = CC_OP_SARB + 2;
-            }
-
-
-	  // Fault is injected into T0
-	  T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_CMP_OP, env->sarl_count);
-
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->sarl_count = 0; 
-	 
-        }else{
-	    count = T1 & 0x1f;
-	    if (count) {
-       		 src = (uint32_t)T0;
-       		 T0 = src >> count;
-		 src = src >> (count - 1);
-
-	        CC_SRC = src;
-	        CC_DST = T0;
-	        CC_OP = CC_OP_SARB + 2;
-    	    }
-
-
-	}
-    }else{ 
-    	count = T1 & 0x1f;
-	if (count) {
-	        src = (uint32_t)T0;
-	        T0 = src >> count;
-	        src = src >> (count - 1);
-
-	        CC_SRC = src;
-	        CC_DST = T0;
-	        CC_OP = CC_OP_SARB + 2;
-    	}
-    }
-
-    FORCE_RET();
-}
-void OPPROTO op_sarl_raw_T0_T1_cc(void)
-{
-    int count;
-    target_long src;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-
-    count = T1 & 0x1f;
-    if (count) {
-        src = (uint32_t)T0;
-        T0 = src >> count;
-        src = src >> (count - 1);
-
-#ifdef MEM_WRITE
-        stl_raw(A0, T0);
-#endif
-        CC_SRC = src;
-        CC_DST = T0;
-        CC_OP = CC_OP_SARB + 2;
-    }
-    FORCE_RET();
-}
-void OPPROTO op_sarl_kernel_T0_T1_cc(void)
 {
-    int count;
-    target_long src;
-
-    count = T1 & 0x1f;
-    if (count) {
-        src = (uint32_t)T0;
-        T0 = src >> count;
-        src = src >> (count - 1);
-
-#ifdef MEM_WRITE
-        stl_kernel(A0, T0);
-#endif
-        CC_SRC = src;
-        CC_DST = T0;
-        CC_OP = CC_OP_SARB + 2;
-    }
-    FORCE_RET();
-}
-
-void OPPROTO op_sarl_user_T0_T1_cc(void)
-{
-    int count;
-    target_long src;
-
-    count = T1 & 0x1f;
-    if (count) {
-        src = (uint32_t)T0;
-        T0 = src >> count;
-        src = src >> (count - 1);
-
-#ifdef MEM_WRITE
-        stl_user(A0, T0);
-#endif
-        CC_SRC = src;
-        CC_DST = T0;
-        CC_OP = CC_OP_SARB + 2;
-    }
-    FORCE_RET();
-}
-
-*/
-void OPPROTO op_sarq_T0_T1(void)
-{
-    int count;
-    target_long src;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-
-    count = T1 & 0x3f;
-    src = (uint64_t)T0;
-    T0 = src >> count;
-    FORCE_RET();
-}
-
-void OPPROTO op_sarb_T0_T1(void)
-{
-    int count;
-    target_long src;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-
-    count = T1 & 0x1f;
-    src = (uint8_t)T0;
-    T0 = src >> count;
-    FORCE_RET();
-}
-
-void OPPROTO op_sarw_T0_T1(void)
-{
-    int count;
-    target_long src;
-
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-   
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_SARL_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-      && (SEFI_helper_hit_dic(env->sarl_count, env->start_of_sarl))
-//     &&	(env->sarl_count == env->chosen_dic)
-     )		
-     // flip start
-     {	
-	if(env->counter>0){ // counter is to count the injection times
-
-    	  count = T1 & 0x1f;
-    	  src = (uint16_t)T0;
-          T0 = src >> count; 
-
-	  // Fault is injected into T0
-	  T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_SARL_OP, env->sarl_count);
-	  opprint_T0(T0);
-
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->sarl_count = 0; 
-	 
-        }else{
-
-
-    	  count = T1 & 0x1f;
-    	  src = (uint16_t)T0;
-          T0 = src >> count; 
-	}
-    }else{
-       count = T1 & 0x1f;
-       src = (uint16_t)T0;
-       T0 = src >> count; 
-    }
-   
-    FORCE_RET();
-}
-
-
-// Added for sarl instruction
-void OPPROTO op_sarl_T0_T1(void)
-{
-    int count;
-    target_long src;
-    
-    SEFI_helper_inject_faults_uint32_reg(&T0, &T1, SEFI_TYPE_SARL);
-    /*
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-   
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_SARL_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-     && (SEFI_helper_hit_dic(env->sarl_count, env->start_of_sarl))
-     //&&	(env->sarl_count == env->chosen_dic)
-     )		
-     // flip start
-     {	
-	if(env->counter>0){ // counter is to count the injection times
-
-    	  count = T1 & 0x1f;
-    	  src = (uint32_t)T0;
-          T0 = src >> count; 
-
-	  // Fault is injected into T0
-	  T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_SARL_OP, env->sarl_count);
-	  opprint_T0(T0);
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->sarl_count = 0; 
-	 
-        }else{
-
-
-    	  count = T1 & 0x1f;
-    	  src = (uint32_t)T0;
-          T0 = src >> count; 
-	}
-    }else{
-       count = T1 & 0x1f;
-       src = (uint32_t)T0;
-       T0 = src >> count; 
-    }
-    */
-    count = T1 & 0x1f;
-    src = (uint32_t)T0;
-    T0 = src >> count; 
-    FORCE_RET();
-}
-
-// fault injection func
-double SEFI_helper_bit_flip_double(double ST0_reg, int op_type, uint64_t dic_count){
-   long int j;
-   unsigned long int flip, tmp;
-   int denom, base, iter; // for generating the random number
-   char str_type[16];
-   // Get the pointer of ST0 to a unsigned long int para
-   tmp = *((unsigned long int *)(&ST0_reg));
-   printf("unmasked Register:%lx, ST0:%d\n",tmp, (int)sizeof(ST0_reg));
-   
-   // for random seed
-   base = env->start_bit; 
-   denom = env->end_bit - env->start_bit;
-
-   flip = 0;  // flip is clear to all 0
-   
-   for(iter = 0; iter < env->num_bit; iter++){   
-     j = rand()%denom+base;
-     // bit flip
-     // For multiple flips 
-     flip = flip | (unsigned long int)((unsigned long int)1<<j);
-   }
-   /*
-   j = rand()%12+52;
-   // bit flip
-   flip= (unsigned long int)((unsigned long int)1<<j);
-   */
-   tmp = tmp ^flip;
-   printf("Eip: 0x%08X, BitFlipMask: %08lX, AfterInjection:%lf, BeforeInjection:%lf DIC:%lu\n", env->eip, flip, *((double *)(&tmp)), (double)ST0_reg, dic_count);
-    switch(op_type){
-     case SEFI_ADD_OP:
-        strcpy(str_type,SEFI_ADD_FAULTY_OP);
-     	break;
-     case SEFI_MUL_OP:
-        strcpy(str_type,SEFI_MUL_FAULTY_OP);
-     	break;
-     case SEFI_CMP_OP:
-        strcpy(str_type,SEFI_CMP_FAULTY_OP);
-     	break; 
-     case SEFI_XOR_OP:
-     	strcpy(str_type,SEFI_XOR_FAULTY_OP);
-	break;
-     case SEFI_SARL_OP:
-	strcpy(str_type,SEFI_SARL_FAULTY_OP);
-	break;
-     case SEFI_IDIVL_OP:
-	strcpy(str_type,SEFI_IDIVL_FAULTY_OP);
-	break;
-     default:
-        strcpy(str_type, "Unknown");
-     	break;	
-   }  
-
-   SEFI_writelog(env->func_name, "FaultyOp:%s,eip:0x%08lX, Original:%lf, BitflipMask:%08lX, AfterInjection:%lf DynamicInstruction:%lu\n",
-                                  str_type,
-				  env->eip,
-				  (double)ST0_reg,
-				  flip,
-				  *((double *)(&tmp)),
-				  dic_count
-				  );
-   
-   // Resigned the flipped value to register	  
-   return *((double *)(&tmp));
-
-}
-
-void opprintf(target_ulong T0_reg, target_ulong T1_reg){
-  //printf("the counter : %d\n", env->counter);
-  //printf("dygen translator marker!\n");
-  //printf("T0:%lu, T1:%lu  T0-T1:%x T1-T0:%x\n", T0_reg, T1_reg, T0_reg-T1_reg, T1_reg-T0_reg);
-}
-
-void opprint_T0(uint32_t T0_reg){
-  //printf("T0:%d (%x)\n", T0_reg, T0_reg);
-}
-
-void init_rand(){
-  srand((unsigned int)time(NULL));
-}
-
-// Help function to implement the probability model
-int SEFI_helper_check_probability(){
-  double j;
-  double probability;
-  
-  probability = env->fault_probability;
-  if(probability == 100)
-    return 1;
-
-  j=drand48()*100; 
-  
-  //printf("random num :%d probability:%d\n",j, env->fault_probability);
-  if(j>=(100-probability))
-    return 1;
-  else
-    return 0;
-}
-
-int SEFI_helper_check_mem(){
-  if(env->eip >= env->inject_start_addr && env->eip <= env->inject_end_addr){
-   // opprinteip();
-    return 1;
-  }
-  else 
-    return 0;
-}
-
-// Check if the dic hits
-// Case 1. fixed probability for injection
-// Case 2. fixed number of injections
-int SEFI_helper_hit_dic(uint64_t current_count, uint64_t lower_bound){
-  int i,j;
-  uint64_t tmp;
-  // Fixed probability for injection
-  if (env->fault_probability !=0){
-    env->counter = 2; // any number larger than 1
-    return SEFI_helper_check_probability();
-  }
-  // Fixed number of injections
-  for(i=0; i<env->counter;i++){
-    if (current_count == env->p_chosen_dic[i]+lower_bound){
-        // For debug only
-#if 0
-  	printf("current_count:%ld, lower_bound:%ld, candidate:%ld\n", current_count, lower_bound, env->p_chosen_dic[i]);
-	for(j=0;j<env->counter;j++)
-		printf(" %d ", env->p_chosen_dic[j]);
-	printf("\n");
-#endif
-	env->p_chosen_dic[i] = env->p_chosen_dic[env->counter-1];
-	return 1;
-    }
-  }
-  return 0;
-}
- 
-// clean the candidate list
-// List is filled with 0
-void SEFI_helper_free_candidates(){
-  int i;
-  for(i=0; i<10000; i++)
-	env->p_chosen_dic[i] = 0;
-}
-
-#if 0
-void OPPROTO op_fadd_ST0_FT0(void){
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->fadd_count++;
-	opprinteip();
-//	opprintcount();
-	//SEFI_helper_save_profiling();
-   }
-
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_FADD_BIT_FLIP     // flip type
-     && SEFI_helper_check_mem()
-//    &&(env->fadd_count == (env->start_of_fadd+env->chosen_dic))
-      && (SEFI_helper_hit_dic(env->fadd_count, env->start_of_fadd))
-   )		// flip start
-     {
-	opprintcount();
-	if(env->counter>0){	
-	  if( SEFI_helper_probability(5)){
-	     FT0 = SEFI_helper_bit_flip_double(FT0, SEFI_ADD_OP, env->fadd_count);
-    	     ST0 += FT0;
-	  }else{
-    	     ST0 += FT0;
-	     ST0 = SEFI_helper_bit_flip_double(ST0, SEFI_ADD_OP, env->fadd_count);
- 	  }
-	  env->counter--;	
-  	  // At the last injection, turn off the injector
-	  if(env->counter==0){  
-	     env->is_inject_triggered = 0;
-	     env->is_inject_allowed = 0;
-	     env->fadd_count = 0;
-	   }  
-	}else{
-    	  ST0 += FT0;
-	} 
-    }
-    else{
-      ST0 += FT0;
-    } 
-    
+    ST0 += FT0;
 }
-#endif
-#if 0
-void OPPROTO op_fadd_ST0_FT0(void){
-   long int j;
-   unsigned long int flip, tmp;
-   srand((unsigned int)time(NULL));
- 
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed && env->is_inject_triggered){
-	if(env->counter>0){ // counter is to count the injection times
-    	  ST0 += FT0;
-
-	  // Get the pointer of ST0 to a unsigned long int para
-	  tmp = *((unsigned long int *)(&ST0));
-
-	  //printf("unmasked Register:%lx, ST0:%d\n",tmp, (int)sizeof(ST0));
-	  // get random seed
-	  j = rand()%12+51;
-	  // bit flip
-	  flip= (unsigned long int)((unsigned long int)1<<j);
-   	  tmp = tmp ^flip;
-
-	  // Resigned the flipped value to register	  
-	  ST0 = *((double *)(&tmp));
-	  //printf("Random Seed:%d, Flip Mask: %lx, Masked Register:%lx, ST0:%f\n", j, flip, tmp, (double)ST0);
-
-	  env->counter--;
-	}else{
-    	  ST0 += FT0;
-	  //env->counter--;
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
 
-	} 
-    }
-    else
-      ST0 += FT0;
-} 
-#endif
-
-#if 1
 void OPPROTO op_fmul_ST0_FT0(void)
 {
-   SEFI_helper_inject_faults_double64_reg(&ST0, &FT0, SEFI_TYPE_FMUL);
     ST0 *= FT0;
 }
-#endif
-
-#if 0
-void OPPROTO op_fmul_ST0_FT0(void)
-{   
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->fmul_count++;
-	//SEFI_helper_save_profiling();
-   }
-
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_FMUL_BIT_FLIP     // flip type
-     && SEFI_helper_check_mem()
-    // &&	(env->fmul_count == (env->start_of_fmul+env->chosen_dic)))		// flip start
-     && (SEFI_helper_hit_dic(env->fmul_count, env->start_of_fmul))
-     )
-     { 
-       // if(env->counter>0){	
-	if(env->counter>0){	
-	  if( SEFI_helper_probability(5)){	// With 50% probabality
-	     FT0 = SEFI_helper_bit_flip_double(FT0, SEFI_MUL_OP, env->fmul_count);
-    	     ST0 *= FT0;
-	  }else{
-    	     ST0 *= FT0;
-	     ST0 = SEFI_helper_bit_flip_double(ST0, SEFI_MUL_OP, env->fmul_count);
- 	  }
-	  env->counter--;	
-	  if(env->counter==0){  
-	     env->is_inject_triggered = 0;
-	     env->is_inject_allowed = 0;
-	     env->fmul_count = 0; 
-	  }
-	}else{
-    	  ST0 *= FT0;
-	} 
-    }
-    else{
-      ST0 *= FT0;
-    } 
-   
-}
-#endif
 
 void OPPROTO op_fsub_ST0_FT0(void)
 {
@@ -3502,115 +2595,13 @@
 
 /* fp operations between STN and ST0 */
 
-#if 0
-void OPPROTO op_fadd_STN_ST0(void)
-{   
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->fadd_count++;
-	//SEFI_helper_save_profiling();
-   }
-
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_FADD_BIT_FLIP     // flip type
-     && SEFI_helper_check_mem()
-    // &&	(env->fadd_count == (env->start_of_fadd+env->chosen_dic) )
-      && (SEFI_helper_hit_dic(env->fadd_count, env->start_of_fadd))
-    // || (env->counter>0 && env->fadd_count>env->chosen_dic)))
-    // &&	(env->fadd_count == env->chosen_dic))		// flip start
-     ){ 
-	opprintcount();
-       // if(env->counter>0){	
-	if(env->counter>0){	
-	  if( SEFI_helper_probability(5)){
-	     ST0 = SEFI_helper_bit_flip_double(ST0, SEFI_ADD_OP, env->fadd_count);
-    	     ST(PARAM1) += ST0;
-	  }else{
-    	     ST(PARAM1) += ST0;
-	     ST(PARAM1) = SEFI_helper_bit_flip_double(ST(PARAM1), SEFI_ADD_OP, env->fadd_count);
- 	  }
-	  env->counter--;	
-	  // At the last injection, turn off the injector
-	  if(env->counter==0){  
-	     env->is_inject_triggered = 0;
-	     env->is_inject_allowed = 0;
-	     env->fadd_count = 0;
-	   }  
-	}else{
-    	  ST(PARAM1) += ST0;
-	} 
-    }
-    else{
-      ST(PARAM1) += ST0;
-    } 
-    
-
-}
-#endif
-
 void OPPROTO op_fadd_STN_ST0(void)
 {
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-    }
-
-    SEFI_helper_inject_faults_double64_reg(&(ST(PARAM1)), &ST0, SEFI_TYPE_FADD); 
     ST(PARAM1) += ST0;
 }
 
-#if 0
-void OPPROTO op_fmul_STN_ST0(void)
-{ 
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-	env->fmul_count++;
-	//SEFI_helper_save_profiling();
-   }
-
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_FMUL_BIT_FLIP     // flip type
-     && SEFI_helper_check_mem()
-     //&&	(env->fmul_count == env->chosen_dic))		// flip start
-     && (SEFI_helper_hit_dic(env->fmul_count, env->start_of_fmul))
-     //&&	(env->fmul_count == (env->start_of_fmul+env->chosen_dic)))		// flip start
-     ){ 
-        //if(env->counter>0){	
-	if(env->counter>0){	
-	  if( SEFI_helper_probability(5)){
-	     ST0 = SEFI_helper_bit_flip_double(ST0, SEFI_MUL_OP, env->fmul_count);
-	     ST(PARAM1) *= ST0;
-	  }else{
-    	     ST(PARAM1) *= ST0;
-	     ST(PARAM1) = SEFI_helper_bit_flip_double(ST(PARAM1), SEFI_MUL_OP, env->fmul_count);
- 	  }
-	  env->counter--;	
-	
-	  if(env->counter==0){  
-	    env->is_inject_triggered = 0;
-	    env->is_inject_allowed = 0;
-	    env->fmul_count = 0; 
- 	  }
-
-	}else{
-    	  ST(PARAM1) *= ST0;
-	} 
-    }
-    else{
-      ST(PARAM1) *= ST0;
-    } 
-    
-}
-#endif
-
 void OPPROTO op_fmul_STN_ST0(void)
 {
-    SEFI_helper_inject_faults_double64_reg(&(ST(PARAM1)), &ST0,SEFI_TYPE_FMUL); 
     ST(PARAM1) *= ST0;
 }
 
Only in PFSEFI_for_patch/target-i386: op.c.cp
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/ops_mem.h /Users/QGuan/Downloads/temu-1.0/target-i386/ops_mem.h
--- PFSEFI_for_patch/target-i386/ops_mem.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/ops_mem.h	2009-11-23 12:38:09.000000000 -0700
@@ -1,7 +1,5 @@
-#include "taintcheck.h"
 void OPPROTO glue(glue(op_ldub, MEMSUFFIX), _T0_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T0 = glue(TC_ldub, MEMSUFFIX)(A0, R_T0*4);
 #else
@@ -11,7 +9,6 @@
 
 void OPPROTO glue(glue(op_ldsb, MEMSUFFIX), _T0_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T0 = glue(TC_ldsb, MEMSUFFIX)(A0, R_T0*4);
 #else
@@ -21,7 +18,6 @@
 
 void OPPROTO glue(glue(op_lduw, MEMSUFFIX), _T0_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T0 = glue(TC_lduw, MEMSUFFIX)(A0, R_T0*4);
 #else
@@ -31,7 +27,6 @@
 
 void OPPROTO glue(glue(op_ldsw, MEMSUFFIX), _T0_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T0 = glue(TC_ldsw, MEMSUFFIX)(A0, R_T0*4);
 #else
@@ -41,7 +36,6 @@
 
 void OPPROTO glue(glue(op_ldl, MEMSUFFIX), _T0_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T0 = glue(TC_ldl, MEMSUFFIX)(A0, R_T0*4);
 #else
@@ -51,7 +45,6 @@
 
 void OPPROTO glue(glue(op_ldub, MEMSUFFIX), _T1_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T1, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T1 = glue(TC_ldub, MEMSUFFIX)(A0, R_T1*4);
 #else
@@ -61,7 +54,6 @@
 
 void OPPROTO glue(glue(op_ldsb, MEMSUFFIX), _T1_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T1, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T1 = glue(TC_ldsb, MEMSUFFIX)(A0, R_T1*4);
 #else
@@ -71,7 +63,6 @@
 
 void OPPROTO glue(glue(op_lduw, MEMSUFFIX), _T1_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T1, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T1 = glue(TC_lduw, MEMSUFFIX)(A0, R_T1*4);
 #else
@@ -81,7 +72,6 @@
 
 void OPPROTO glue(glue(op_ldsw, MEMSUFFIX), _T1_A0)(void)
 {
-//    SEFI_helper_inject_faults_uint32_reg(&A0, &T1, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T1 = glue(TC_ldsw, MEMSUFFIX)(A0, R_T1*4);
 #else
@@ -91,7 +81,6 @@
 
 void OPPROTO glue(glue(op_ldl, MEMSUFFIX), _T1_A0)(void)
 {
-    //SEFI_helper_inject_faults_uint32_reg(&A0, &T1, SEFI_TYPE_LD);
 #if TAINT_ENABLED
     T1 = glue(TC_ldl, MEMSUFFIX)(A0, R_T1*4);
 #else
@@ -161,11 +150,10 @@
 void OPPROTO glue(glue(op_ldq, MEMSUFFIX), _env_A0)(void)
 {
     uint64_t *p;
-    //SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
     p = (uint64_t *)((char *)env + PARAM1);
     *p = glue(ldq, MEMSUFFIX)(A0);
 }
-///
+
 void OPPROTO glue(glue(op_stq, MEMSUFFIX), _env_A0)(void)
 {
     uint64_t *p;
@@ -177,7 +165,6 @@
 void OPPROTO glue(glue(op_ldo, MEMSUFFIX), _env_A0)(void)
 {
     XMMReg *p;
-    ///SEFI_helper_inject_faults_uint32_reg(&A0, &T0, SEFI_TYPE_LD);
     p = (XMMReg *)((char *)env + PARAM1);
     p->XMM_Q(0) = glue(ldq, MEMSUFFIX)(A0);
     p->XMM_Q(1) = glue(ldq, MEMSUFFIX)(A0 + 8);
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/ops_sse.h /Users/QGuan/Downloads/temu-1.0/target-i386/ops_sse.h
--- PFSEFI_for_patch/target-i386/ops_sse.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/ops_sse.h	2009-11-23 12:38:09.000000000 -0700
@@ -34,12 +34,6 @@
 #define Q(n) XMM_Q(n)
 #define SUFFIX _xmm
 #endif
-#if defined(__i386__) && __GNUC__ >= 4
-#define RegCopy(d, s) __builtin_memcpy(&(d), &(s), sizeof(d))
-#endif
-#ifndef RegCopy
-#define RegCopy(d, s) d = s
-#endif
 
 void OPPROTO glue(op_psrlw, SUFFIX)(void)
 {
@@ -598,7 +592,7 @@
     r.W(1) = s->W((order >> 2) & 3);
     r.W(2) = s->W((order >> 4) & 3);
     r.W(3) = s->W((order >> 6) & 3);
-    RegCopy(*d, r);
+    *d = r;
 }
 #else
 void OPPROTO op_shufps(void)
Only in PFSEFI_for_patch/target-i386: ops_sse.h.orig
Only in PFSEFI_for_patch/target-i386: ops_sse.h.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/ops_template.h /Users/QGuan/Downloads/temu-1.0/target-i386/ops_template.h
--- PFSEFI_for_patch/target-i386/ops_template.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/ops_template.h	2009-11-23 12:38:09.000000000 -0700
@@ -298,7 +298,6 @@
     sf = lshift(CC_DST, 8 - DATA_BITS) & 0x80;
     /* of is defined if shift count == 1 */
     of = lshift(CC_SRC ^ CC_DST, 12 - DATA_BITS) & CC_O;
-    print_something();
 #if TAINT_FLAGS
 	UPDATE_CC_FLAGS(cf | pf | af | zf | sf | of);
     taintcheck_update_all_eflags();
@@ -312,18 +311,16 @@
 	UPDATE_CF((CC_SRC >> (DATA_BITS - 1)) & CC_C);
     taintcheck_update_eflags(CC_C);
 #endif
-    print_something();
     return (CC_SRC >> (DATA_BITS - 1)) & CC_C;
 }
 
 #if DATA_BITS == 32
 static int glue(compute_c_sar, SUFFIX)(void)
-{	
+{
 #if TAINT_FLAGS
 	UPDATE_CF(CC_SRC & 1);
     taintcheck_update_eflags(CC_C);
 #endif
-    print_something();
     return CC_SRC & 1;
 }
 #endif
@@ -331,7 +328,7 @@
 static int glue(compute_all_sar, SUFFIX)(void)
 {
     int cf, pf, af, zf, sf, of;
-    cf = CC_SRC & 1; 
+    cf = CC_SRC & 1;
     pf = parity_table[(uint8_t)CC_DST];
     af = 0; /* undefined */
     zf = ((DATA_TYPE)CC_DST == 0) << 6;
@@ -342,7 +339,6 @@
 	UPDATE_CC_FLAGS(cf | pf | af | zf | sf | of);
     taintcheck_update_all_eflags();
 #endif
-    print_something();
     return cf | pf | af | zf | sf | of;
 }
 
@@ -637,12 +633,9 @@
     FORCE_RET();
 }
 
-
-#if DATA_BITS !=32
 void OPPROTO glue(glue(op_shr, SUFFIX), _T0_T1)(void)
 {
     int count;
-    print_something();
     count = T1 & SHIFT1_MASK;
     T0 &= DATA_MASK;
     T0 = T0 >> count;
@@ -653,9 +646,7 @@
 #endif
     FORCE_RET();
 }
-#endif
-/*
-#if DATA_BITS > 32
+
 void OPPROTO glue(glue(op_sar, SUFFIX), _T0_T1)(void)
 {
     int count;
@@ -671,8 +662,6 @@
 #endif
     FORCE_RET();
 }
-#endif
-*/
 
 #undef MEM_WRITE
 #include "ops_template_mem.h"
@@ -696,7 +685,6 @@
     int count;
     count = T1 & SHIFT_MASK;
     CC_SRC = T0 >> count;
-    print_something();
 #if TAINT_FLAGS
 //	taintcheck_reg_clean2(R_T1*4+1, 3);
 	taintcheck_reg2reg(R_T0, R_CC_SRC, 4);
@@ -709,7 +697,6 @@
     count = T1 & SHIFT_MASK;
     T1 = T0 >> count;
     T0 |= (((target_long)1) << count);
-    print_something();
 #if TAINT_ENABLED
 	taintcheck_reg_clean2(R_T1*4+1, 3);
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
@@ -723,7 +710,6 @@
     count = T1 & SHIFT_MASK;
     T1 = T0 >> count;
     T0 &= ~(((target_long)1) << count);
-    print_something();
 #if TAINT_ENABLED
 	taintcheck_reg_clean2(R_T1*4+1, 3);
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
@@ -737,7 +723,6 @@
     count = T1 & SHIFT_MASK;
     T1 = T0 >> count;
     T0 ^= (((target_long)1) << count);
-    print_something();
 #if TAINT_ENABLED
 	taintcheck_reg_clean2(R_T1*4+1, 3);
     taintcheck_fn2regs(R_T0, R_T1, R_T0, 4);
@@ -760,7 +745,6 @@
     target_long res;
     
     res = T0 & DATA_MASK;
-    print_something();
     if (res != 0) {
         count = 0;
         while ((res & 1) == 0) {
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/ops_template_mem.h /Users/QGuan/Downloads/temu-1.0/target-i386/ops_template_mem.h
--- PFSEFI_for_patch/target-i386/ops_template_mem.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/ops_template_mem.h	2009-11-23 12:38:09.000000000 -0700
@@ -324,90 +324,38 @@
     FORCE_RET();
 }
 
-//#if DATA_BITS !=32
 void OPPROTO glue(glue(op_sar, MEM_SUFFIX), _T0_T1_cc)(void)
 {
     int count;
     target_long src;
-    if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && SEFI_helper_check_mem()){
-        opprinteip();
-	env->sarl_count++;
-	SEFI_helper_save_profiling();
-    }
-   // Only when inject is allowed and triggered by monitor
-   if(env->is_inject_allowed 
-     && env->is_inject_triggered 
-     && env->inject_type&SEFI_SARL_BIT_FLIP      // flip type
-     && SEFI_helper_check_mem()
-     &&	(env->sarl_count == env->chosen_dic)
-     )		
-     // flip start
-     {	
-	if(env->counter>0){ // counter is to count the injection times
- 	   count = T1 & SHIFT1_MASK;
-	   if (count) {
-       	     src = (DATA_STYPE)T0;
-	     T0 = src >> count;
-       	     src = src >> (count - 1);
-	     // Fault is injected into T0
-	     T0 = SEFI_helper_bit_flip_ulong(T0, SEFI_SARL_OP, env->sarl_count);
-	     print_something_t(T0);
-
-#ifdef MEM_WRITE
-	     glue(st, MEM_SUFFIX)(A0, T0);
-#endif
-	     CC_SRC = src;
-	     CC_DST = T0;
-	     CC_OP = CC_OP_SARB + SHIFT;
-           }
-
-
-	  env->counter--;	
-	
-	  env->is_inject_triggered = 0;
-	  env->is_inject_allowed = 0;
-	  env->sarl_count = 0; 
-	 
-        }else{
- 	   count = T1 & SHIFT1_MASK;
-	   if (count) {
-       	     src = (DATA_STYPE)T0;
-	     T0 = src >> count;
-       	     src = src >> (count - 1);
-
-#ifdef MEM_WRITE
-	     glue(st, MEM_SUFFIX)(A0, T0);
-#endif
-	     CC_SRC = src;
-	     CC_DST = T0;
-	     CC_OP = CC_OP_SARB + SHIFT;
-           }
-
-
-	}
-    }else{ 
-	   count = T1 & SHIFT1_MASK;
-	   if (count) {
-       	     src = (DATA_STYPE)T0;
-	     T0 = src >> count;
-       	     src = src >> (count - 1);
-
-#ifdef MEM_WRITE
-	     glue(st, MEM_SUFFIX)(A0, T0);
-#endif
-	     CC_SRC = src;
-	     CC_DST = T0;
-	     CC_OP = CC_OP_SARB + SHIFT;
-           }
-
-    }
 
+    count = T1 & SHIFT1_MASK;
+    if (count) {
+        src = (DATA_STYPE)T0;
+        T0 = src >> count;
+        src = src >> (count - 1);
+#if TAINT_ENABLED
+		taintcheck_reg_clean2(R_T1*4+1, 3);
+        taintcheck_fn2regs(R_T0, R_T1, R_T0, DATA_BYTES);
+#endif
 
+#ifdef MEM_WRITE
+#if TAINT_ENABLED
+        glue(TC_st, MEM_SUFFIX)(A0, T0, R_T0*4);
+#else
+        glue(st, MEM_SUFFIX)(A0, T0);
+#endif
+#endif
+        CC_SRC = src;
+        CC_DST = T0;
+        CC_OP = CC_OP_SARB + SHIFT;
+#if TAINT_FLAGS
+		taintcheck_fn2regs(R_T1, R_T0, R_CC_SRC, DATA_BYTES);
+		taintcheck_reg2reg(R_T0, R_CC_DST, DATA_BYTES);
+#endif
+    }
     FORCE_RET();
 }
-//#endif
 
 #if DATA_BITS == 16
 /* XXX: overflow flag might be incorrect in some cases in shldw */
Only in PFSEFI_for_patch/target-i386: tags
diff --exclude=tracecap -ur PFSEFI_for_patch/target-i386/translate.c /Users/QGuan/Downloads/temu-1.0/target-i386/translate.c
--- PFSEFI_for_patch/target-i386/translate.c	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-i386/translate.c	2009-11-23 12:38:09.000000000 -0700
@@ -1177,15 +1177,7 @@
     gen_ ## op(s, ot);                                                        \
     gen_op_dec_ECX[s->aflag]();                                               \
     gen_op_set_cc_op(CC_OP_SUBB + ot);                                        \
-    if (s->jmp_opt)							      \
-	gen_op_string_jnz_sub[nz][ot](l2);				      \
-    else {								      \
-	gen_op_setz_T0_cc();					              \
-	if (nz)								      \
-	    gen_op_jnz_T0_label(l2);					      \
-	else								      \
-	    gen_op_jz_T0_label(l2);					      \
-    }									      \
+    gen_op_string_jnz_sub[nz][ot](l2);\
     if (!s->jmp_opt)                                                          \
         gen_op_jz_ecx[s->aflag](l2);                                          \
     gen_jmp(s, cur_eip);                                                      \
@@ -1285,7 +1277,6 @@
     gen_op_setle_T0_cc,
 };
 
-#ifndef TAINT_ENABLED
 static GenOpFunc *gen_setcc_sub[4][8] = {
     [OT_BYTE] = {
         NULL,
@@ -1331,9 +1322,6 @@
 #endif
 };
 
-#endif //TAINT_ENABLED
-
-
 static GenOpFunc *gen_op_fp_arith_ST0_FT0[8] = {
     gen_op_fadd_ST0_FT0,
     gen_op_fmul_ST0_FT0,
@@ -2014,7 +2002,6 @@
     inv = b & 1;
     jcc_op = (b >> 1) & 7;
     switch(s->cc_op) {
-#ifndef TAINT_ENABLED
         /* we optimize the cmp/jcc case */
     case CC_OP_SUBB:
     case CC_OP_SUBW:
@@ -2061,11 +2048,8 @@
             goto slow_jcc;
         }
         break;
-#endif //TAINT_ENABLED
     default:
-#ifndef TAINT_ENABLED
     slow_jcc:
-#endif //TAINT_ENABLED
         if (s->cc_op != CC_OP_DYNAMIC)
             gen_op_set_cc_op(s->cc_op);
         func = gen_setcc_slow[jcc_op];
Only in PFSEFI_for_patch/target-i386: translate.c.orig
Only in PFSEFI_for_patch/target-i386: translate.c.rej
diff --exclude=tracecap -ur PFSEFI_for_patch/target-ppc/exec.h /Users/QGuan/Downloads/temu-1.0/target-ppc/exec.h
--- PFSEFI_for_patch/target-ppc/exec.h	2016-06-29 13:57:35.000000000 -0600
+++ /Users/QGuan/Downloads/temu-1.0/target-ppc/exec.h	2009-11-23 12:38:07.000000000 -0700
@@ -37,7 +37,11 @@
 #define FT1 (env->ft1)
 #define FT2 (env->ft2)
 
-#define RETURN() FORCE_RET()
+#if defined (DEBUG_OP)
+#define RETURN() __asm__ __volatile__("nop");
+#else
+#define RETURN() __asm__ __volatile__("");
+#endif
 
 #include "cpu.h"
 #include "exec-all.h"
